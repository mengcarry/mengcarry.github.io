<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[HashMap相关知识点回顾总结]]></title>
    <url>%2F2017%2F12%2F08%2FHashMap%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9%2F</url>
    <content type="text"><![CDATA[在笔试和面试的过程中，Java集合框架毫无疑问是考察的重点，貌似面试官对这都情有独钟，而有关HashMap的考察更是重中之重和难点，一个小小的HashMap不仅能反应出你对Java集合的掌握程度，更能反映出面试者对数据结构的熟悉情况和设计数据结构的思维能力，很容易在这个问题上尴尬地看着面试官发呆，搞不好就拜拜了。根据个人对这个问题的理解和一些网上的资料在这里做个汇总解析，与各位共享。废话不多说，要想搞透彻HashMap，那咱们就先从HashMap的原理说起。 HashMap与哈希表HashMap从本质上说就是哈希表，其底层实现就是围绕哈希表展看的，搞明白了这个很多问题就很容易理解了。那哈希表又是什么东东呢？ 哈希表的核心思想就是让记录的关键字和存储位置建立一一映射关系，这样我们就可以通过Key直接获得相对应的Value，好比我们通过索引可以直接获得数组对应的某个值一样，而这种一一映射关系要通过某个数学函数来构造出来，这个函数就是所谓的哈希函数。 而哈希函数有五种实现方式： A. 直接定址法：取关键字的线性函数值作为哈希地址。 B. 数字分析法：取关键字的中的若干位作为哈希地址。 C. 平方取中法：取关键字平方后的中间几位作为哈希地址。 D. 折叠法：将关键字分割成位数相同的几部分（最后一部分可以不同），然后取这几部分的叠加和作为哈希地址。 E. 除留余数法：H(key) = key MOD p ，p&lt;=m ，m为不大于哈希表的数。 F. 随机函数法 上述五中实现方式中最常用的是除留余数法，而通过哈希函数寻址的过程可能出现“冲突”——即若干个不同的key却对应相同的哈希地址。解决哈希冲突有如下的方法： A. 开放地址法：H=(H(kyt)+d) MOD m ，m为哈希表表长。 （1）d=1,2，3——&gt; m-1 时，称谓线性探测再散列 （2）d=1^2，-1^2—-&gt;+(-)k^2时，称为二次线性再散列。 （3）d为伪随即序列时，称为伪随即序列再散列。 B .再哈希法 H=RH(key)，RH()为不同的哈希函数，即在地址冲突时计算另一个哈希函数地址，直到不再发生冲突。 C .链地址法 将所有哈希地址冲突的记录存储在同一个线性链表中 D 公共溢出区法 将所有哈希地址冲突的记录都填入到溢出表中 而HashMap的实现与哈希函数的选择和哈希地址冲突的解决方案密切相关，详情继续看下文。 2.HashMap的具体实现HashMap的实现采用了除留余数法形式的哈希函数和链地址法解决哈希地址冲突的方案。这样就涉及到两种基本的数据结构：数组和链表。数组的索引就是对应的哈希地址，存放的是链表的头结点即插入链表中的最后一个元素，链表存放的是哈希地址冲突的不同记录。 链表的结点设计如下：1234567891011static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final K key; V value; Entry&lt;K,V&gt; next; final int hash;&#125; next作为引用指向下一个记录。在HashMap中设计了一个Entry类型的数组用来存放Entry的实例即链表结点。1234567/** * The table, resized as necessary. Length MUST Always be a power of two. */ transient Entry[] table; 除留余数法形式的哈希函数：1234567891011/** * Returns index for hash code h. */ static int indexFor(int h, int length) &#123; return h &amp; (length-1); //和除留余数等价&#125; 当我们往HashMap中put元素的时候，先根据key的hashCode重新计算hash值，根据hash值得到这个元素在数组中的位置（即下标），如果数组该位置上已经存放有其他元素了，那么在这个位置上的元素将以链表的形式存放，新加入的放在链头，最先加入的放在链尾，数组中存储的是最后插入的元素 。如果数组该位置上没有元素，就直接将该元素放到此数组中的该位置上。 以上是有关HashMap底层实现的说明，几乎所有有关HashMap的题目都是基于上述理论展看的。下面是收集到的一些HashMap相关的笔试面试题的解析：1.HashMap与Hashtable的区别： HashMap可以接受null键值和值，而Hashtable则不能。 Hashtable是线程安全的，通过synchronized实现线程同步。而HashMap是非线程安全的，但是速度比Hashtable快。 2.HashMap的原理 参见上文中的HashMap的具体实现 3.当两个对象的hashcode相同怎么办 当哈希地址冲突时，HashMap采用了链地址法的解决方式，将所有哈希地址冲突的记录存储在同一个线性链表中。具体来说就是根据hash值得到这个元素在数组中的位置（即下标），如果数组该位置上已经存放有其他元素了，那么在这个位置上的元素将以链表的形式存放，新加入的放在链头，最先加入的放在链尾。 4.如果两个键的hashcode相同，你如何获取值对象 HashMap在链表中存储的是键值对，找到哈希地址位置之后，会调用keys.equals()方法去找到链表中正确的节点，最终找到要找的值对象 5.如果HashMap的大小超过了负载因子(load factor)定义的容量，怎么办 HashMap默认的负载因子大小为0.75，也就是说，当一个map填满了75%的空间的时候，和其它集合类(如ArrayList等)一样，将会创建原来HashMap大小的两倍的数组，来重新调整map的大小，并将原来的对象放入新的数组中。 6.为什么String, Interger这样的wrapper类（包装类）适合作为键？ String, Interger这样的wrapper类是final类型的，具有不可变性，而且已经重写了equals()和hashCode()方法了。其他的wrapper类也有这个特点。不可变性是必要的，因为为了要计算hashCode()，就要防止键值改变，如果键值在放入时和获取时返回不同的hashcode的话，那么就不能从HashMap中找到你想要的对象。 7.ConcurrentHashMap和Hashtable的区别 Hashtable和ConcurrentHashMap有什么分别呢？它们都可以用于多线程的环境，但是当Hashtable的大小增加到一定的时候，性能会急剧下降，因为迭代时需要被锁定很长的时间。因为ConcurrentHashMap引入了分割(segmentation)，不论它变得多么大，仅仅需要锁定map的某个部分，而其它的线程不需要等到迭代完成才能访问map。简而言之，在迭代的过程中，ConcurrentHashMap仅仅锁定map的某个部分，而Hashtable则会锁定整个map。 8.HashMap的遍历 第一种: Map map = new HashMap(); Iterator iter = map.entrySet().iterator(); while (iter.hasNext()) { Map.Entry entry = (Map.Entry) iter.next(); Object key = entry.getKey(); Object val = entry.getValue(); } 效率高,以后一定要使用此种方式！第二种: Map map = new HashMap(); Iterator iter = map.keySet().iterator(); while (iter.hasNext()) { Object key = iter.next(); Object val = map.get(key); } 效率低,以后尽量少使用！ 可是为什么第一种比第二种方法效率更高呢？ HashMap这两种遍历方法是分别对keyset及entryset来进行遍历，但是对于keySet其实是遍历了2次，一次是转为iterator，一次就从hashmap中取出key所对于的value。而entryset只是遍历了第一次，它把key和value都放到了entry中，即键值对，所以就快了。 先总结到这吧，以后遇到有价值的hashmap相关的题目日后再做更新，文章不足之处，反应各位拍砖指正。。。。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL error 1449]]></title>
    <url>%2F2017%2F11%2F08%2FMySQL%20error%201449%2F</url>
    <content type="text"><![CDATA[问 题 描 述在从线上扒库到本地的时，创建视图碰到的这样一个问题： 1MySQL error 1449: The user specified as a definer (”@”) does not exist 原 因从一个数据库或服务器导出视图/触发器/过程到另一个创建该对象的用户不再存在时，通常会出现这种情况。 解 决 方 法在mysql环境下执行以下脚本即可。 123GRANT ALL ON . TO ”@” IDENTIFIED BY ‘complex-password’;FLUSH PRIVILEGES; 不过在此操作之前，你要确定是否可以给这个用户全部的权限。]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>数据库</tag>
        <tag>脚本</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo-NexT搭建个人博客（五）]]></title>
    <url>%2F2017%2F10%2F15%2Fhexo-next-five%2F</url>
    <content type="text"><![CDATA[在这之前，我写过四篇关于 Hexo + NexT 构建博客的文章。=》【传送门】 本文将会介绍一些自定义的功能。相较于之前主要是修改配置文件中的内容，现在更多的是动手改源码来实现功能，而且还能帮你搞懂一些 Hexo NexT 的源码。如果你能弄懂源码的一些流程和逻辑，那么，你将能更好的来实现自己的一些想法。 文章封面文章封面的意思就是：在博客首页的时候会显示文章的封面图片，进入这篇文章的详细页面后，将不显示这张图片。 如果想添加文章封面的话，需要添加一个字段属性：summary_img，summary_img 的值是图片的路径。 例如：12345678---title: CSS 各种Hack手段date: 2017-06-25 03:25:24categories: 前端tags: [CSS]comments: falsesummary_img: /images/css-hack-1.png--- 具体实现细节如下：修改 \themes\next\layout\_macro\post.swing 文件。将代码：12345&#123;% if post.summary_img %&#125; &lt;div class=&quot;out-img-topic&quot;&gt; &lt;img src=&#123;&#123; post.summary_img &#125;&#125; class=&quot;img-topic&quot;&gt; &lt;/div&gt;&#123;% endif %&#125; 添加到下图所示的位置 这样的话，就可以使用 summary_img: imageurl 来设置文章封面了。 开启了文章封面的文章，我建议将 &lt;!-- more --&gt; 放在文章内容的开头，像这样： 网页加载进度条打开 /themes/next/layout/_partials/head.swing 文件，在文件末尾添加如下代码：12&lt;!-- 网页加载条 --&gt;&lt;script src=&quot;https://neveryu.github.io/js/src/pace.min.js&quot;&gt;&lt;/script&gt; 然后，打开 /themes/source/css/_custom/custom.styl 文件，在文件末尾添加如下代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879/*网页加载条*//* This is a compiled file, you should be editing the file in the templates directory */.pace &#123; -webkit-pointer-events: none; pointer-events: none; -webkit-user-select: none; -moz-user-select: none; user-select: none;&#125;.pace-inactive &#123; display: none;&#125;.pace .pace-progress &#123; background: #1e92fb; position: fixed; z-index: 2000; top: 0; right: 100%; width: 100%; height: 3px;&#125;.pace .pace-progress-inner &#123; display: block; position: absolute; right: 0px; width: 100px; height: 100%; box-shadow: 0 0 10px #e90f92, 0 0 5px #e90f92; opacity: 1.0; -webkit-transform: rotate(3deg) translate(0px, -4px); -moz-transform: rotate(3deg) translate(0px, -4px); -ms-transform: rotate(3deg) translate(0px, -4px); -o-transform: rotate(3deg) translate(0px, -4px); transform: rotate(3deg) translate(0px, -4px);&#125;.pace .pace-activity &#123; display: block; position: fixed; z-index: 2000; top: 15px; right: 15px; width: 14px; height: 14px; border: solid 2px transparent; border-top-color: #e90f92; border-left-color: #e90f92; border-radius: 10px; -webkit-animation: pace-spinner 400ms linear infinite; -moz-animation: pace-spinner 400ms linear infinite; -ms-animation: pace-spinner 400ms linear infinite; -o-animation: pace-spinner 400ms linear infinite; animation: pace-spinner 400ms linear infinite;&#125;@-webkit-keyframes pace-spinner &#123; 0% &#123; -webkit-transform: rotate(0deg); transform: rotate(0deg); &#125; 100% &#123; -webkit-transform: rotate(360deg); transform: rotate(360deg); &#125;&#125;@-moz-keyframes pace-spinner &#123; 0% &#123; -moz-transform: rotate(0deg); transform: rotate(0deg); &#125; 100% &#123; -moz-transform: rotate(360deg); transform: rotate(360deg); &#125;&#125;@-o-keyframes pace-spinner &#123; 0% &#123; -o-transform: rotate(0deg); transform: rotate(0deg); &#125; 100% &#123; -o-transform: rotate(360deg); transform: rotate(360deg); &#125;&#125;@-ms-keyframes pace-spinner &#123; 0% &#123; -ms-transform: rotate(0deg); transform: rotate(0deg); &#125; 100% &#123; -ms-transform: rotate(360deg); transform: rotate(360deg); &#125;&#125;@keyframes pace-spinner &#123; 0% &#123; transform: rotate(0deg); transform: rotate(0deg); &#125; 100% &#123; transform: rotate(360deg); transform: rotate(360deg); &#125;&#125;/*网页加载条 END*/ 开发环境自动刷新在 Hexo-NexT搭建个人博客（一） 已经提到了本地调试三部曲：123hexo cleanhexo generatehexo server --debug 然后我在项目的 package.json 中配成了这样：1&quot;dev&quot;: &quot;hexo clean &amp;&amp; hexo generate &amp;&amp; hexo server --debug&quot;, 这样的话，我执行 npm run dev 就可以启动本地环境了，省去了前面需要分别敲三次命令的步骤。为什么可以这样写，详情看这里：npm 全面介绍 这样还不爽，我希望在写博客的时候，按下 Ctrl + S 后能自动刷新浏览器，看到实时的效果，省去了自己手动刷新浏览器的过程，在双屏下，真的很好用，一边写一边看。具体的做法是:在项目的根目录下添加一个 gulpfile.js 文件。然后安装 gulpfile.js 里面的依赖包。 gulpfile.js 里面有一个 dev-proxy 方法，会代理本地的 4000 端口，并且监听文件变化，如有变化就会自动刷新浏览器。 最后，我们的开发步骤就变成这样了：先打开一个 Terminal ，使用 npm run dev 开启本地的博客服务。然后再开一个 Terminal，使用 gulp 命令来开启监听和代理服务。 代码压缩在项目的根目录下，执行以下命令：12cnpm install gulp -gcnpm install gulp-minify-css gulp-uglify gulp-htmlmin gulp --save-dev 然后在 gulpfile.js 里面写上相关代码。 然后执行 gulp min 就会根据 gulpfile.js 中的配置，对 public 目录中的静态资源文件进行压缩。 鼠标右键 -&gt; 查看网页源代码，可以看到已经是压缩过的。 自定义页面与目录下面介绍两种方法： 第一种方法是使用 Hexo 提供的跳过渲染配置，适用于整个目录的设置。 具体步骤，打开博客根目录_config.yml，找到其中 skip_render 配置项，这个用来配置 /source/ 中需要跳过渲染的文件或目录，例如希望跳过 /source/projects/ 里的所有文件渲染，可以配置为：1skip_render: projects/** 匹配规则是一种类似正则的规则，官方给出的参考是这个。另外在测试这个功能的时候发现，Hexo 的内部缓存不是特别好用，有时候你修改了配置但生成出来的内容不一定及时应用了新配置，最好在生成之前执行一下 hexo clean 命令，清除掉旧的生成文件和缓存。 第二种方法是给单个文件添加不应用模板的标记，适用于个别特殊文件的处理。例如我们的网站如果要使用百度统计，往往需要在根目录放一个 html 格式的验证文件，这个文件默认也会经过用主题模板渲染，避免渲染的办法就是在文件头部添加如下内容： 123---layout: false--- 这样，这个文件就不会经过模板渲染，最终发布到 /public/ 里的文件就是去掉标记后的文件的样子。 关于 categories 和 tags 页面 Cannot GET 的解决方案有同学反馈在配置文件中配置了 categories 和 tags 后依然没有 categories 和 tags 页面，提示 Cannot GET。 其实在配置了 categories 和 tags 后，还需要在 /source/ 目录下新建 categories 目录和 tags 目录，里面的要有 index.md 文件，并且文件开头不能少，也不能写错。]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[“阀值”与“阈值”的区别]]></title>
    <url>%2F2017%2F09%2F07%2Fdifference%2F</url>
    <content type="text"><![CDATA[真相请看下图红色框里内容（手动微笑）啥？？你跟我说没看懂，好吧，说的再明白点，“阀（fá）值”是一个错误的用词，其正确用法是“阈（yù）值”。 阀fá 控制、开关、把持。 机械名词,指在管道中用来控制液体或气体的部件。意为阀门、开关、把持。如截止阀、减压阀、安全阀。阈yù 范围,边界,程度。门槛、门限,引申为边界、界阈、视阈。可见“阀”与“阈”是词义不同的2个词。 怎么说呢，虽然现在越来越多的人开始用“阀值”代替“阈值”，但这毕竟是个将错就错的事，从治学严谨的角度来讲，应该加以改正，但是现在将错就错的人越来越多，甚至在学术界都有这样的情况出现，所以现在也隐隐有“阀值”取代“阈值”正统地位的趋势。甚至在最新的字典中都能找到“阀值”一词，简直荒唐至极。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>阀值</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java中的时间戳]]></title>
    <url>%2F2017%2F08%2F04%2Fjava%E4%B8%AD%E7%9A%84%E6%97%B6%E9%97%B4%E6%88%B3%2F</url>
    <content type="text"><![CDATA[时间戳的定义 时间戳（timestamp），一个能表示一份数据在某个特定时间之前已经存在的、 完整的、 可验证的数据,通常是一个字符序列，唯一地标识某一刻的时间。使用数字签名技术产生的数据， 签名的对象包括了原始文件信息、 签名参数、 签名时间等信息。广泛的运用在知识产权保护、 合同签字、 金融帐务、 电子报价投标、 股票交易等方面。时间戳在程序中通常指的是文件属性里的创建、修改、访问时间。数字时间戳技术是数字签名技术一种变种的应用。在电子商务交易文件中，时间是十分重要的信息。在书面合同中，文件签署的日期和签名一样均是十分重要的防止文件被伪造和篡改的关键性内容。数字时间戳服务（DTS：digital time stamp service）是网上电子商务安全服务项目之一，能提供电子文件的日期和时间信息的安全保护。时间戳（time-stamp）是一个经加密后形成的凭证文档，它包括三个部分： （1）需加时间戳的文件的摘要（digest）； （2）DTS收到文件的日期和时间；（3）DTS的数字签名。 一般来说，时间戳产生的过程为：用户首先将需要加时间戳的文件用Hash编码加密形成摘要，然后将该摘要发送到DTS，DTS在加入了收到文件摘要的日期和时间信息后再对该文件加密（数字签名），然后送回用户。 书面签署文件的时间是由签署人自己写上的，而数字时间戳则不然，它是由认证单位DTS来加的，以DTS收到文件的时间为依据。 时间戳转化为Date（or String）代码如下： 1234567//时间戳转化为Sting或Date SimpleDateFormat format = newSimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;); Long time=newLong(445555555); String d = format.format(time); Date date=format.parse(d); System.out.println(&quot;Format To String(Date):&quot;+d); System.out.println(&quot;Format To Date:&quot;+date); 运行结果：1Format To String(Date):1970-01-06 11:45:55 Date（or String）转化为时间戳代码如下： 123456//Date或者String转化为时间戳 SimpleDateFormat format = newSimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;); String time=&quot;1970-01-06 11:45:55&quot;; Date date = format.parse(time); System.out.print(&quot;Format To times:&quot;+date.getTime()); ` 运行结果：1Format To times:445555000 注意1.定义SimpleDateFormat时newSimpleDateFormat(“yyyy-MM-dd HH:mm:ss”);里面字符串头尾不能有空格，有空格那是用转换时对应的时间空格也要有空格（两者是对应的），比如下列代码： 12345//Date或者String转化为时间戳 SimpleDateFormat format = newSimpleDateFormat(&quot; yyyy-MM-dd HH:mm:ss &quot;); String time=&quot;1970-01-06 11:45:55&quot;; Date date = format.parse(time); System.out.print(&quot;Format To times:&quot;+date.getTime()); 运行结果（报错）：1Exception in thread main Java.text.ParseException: Unparseable date: “1970-01-06 11:45:55” 改正：1234SimpleDateFormat format = newSimpleDateFormat(&quot; yyyy-MM-dd HH:mm:ss &quot;); String time=&quot; 1970-01-06 11:45:55 &quot;;//注：改正后这里前后也加了空格 Date date = format.parse(time); System.out.print(&quot;Format To times:&quot;+date.getTime()); 运行结果：1Format To times:445555000 2.java中Date类中的getTime()是获取时间戳的，java中生成的时间戳精确到毫秒级别，而unix中精确到秒级别，所以通过java生成的时间戳需要除以1000。 代码如下：1234567891011121314151617181920import java.text.ParseException; import java.text.SimpleDateFormat; import java.util.Date; public class Baidu &#123; /** * @param args */ public static void main(String[] args) &#123; try &#123; String time = &quot;2011/07/29 14:50:11&quot;; Date date = new SimpleDateFormat(&quot;yyyy/MM/dd HH:mm:ss&quot;).parse(time); long unixTimestamp = date.getTime()/1000; System.out.println(unixTimestamp); &#125; catch (ParseException e) &#123; e.printStackTrace(); &#125; &#125; &#125;]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>时间戳</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS 各种Hack手段]]></title>
    <url>%2F2017%2F06%2F25%2Fcss-hack%2F</url>
    <content type="text"><![CDATA[随着浏览器的发展，css hack 技术的使用应该越来越少了，但是在某些关键时刻以及综合的WEB应用或者老项目中，可能还需要使用 css hack 技术来解决一些问题。 css hack 分类css hack 分类大致有 3 种表现形式：IE条件注释法、CSS属性前缀法以及选择器前缀法。 IE 条件注释法（即 HTML 条件注释 Hack）：针对所有IE(注：IE10+ 已经不再支持条件注释)：&lt;!--[if IE]&gt;IE浏览器显示的内容 &lt;![endif]--&gt;； 针对 IE6 及以下版本：&lt;!--[if lt IE 6]&gt;只在IE6-显示的内容 &lt;![endif]--&gt;。这类 Hack 不仅对 CSS 生效，对写在判断语句里面的所有代码都会生效。 属性前缀法（即类内部 Hack）：例如 IE6 能识别下划线 _ 和星号 *，IE7 能识别星号 *，但不能识别下划线 _，IE6~IE10 都认识 \9，但 firefox 前述三个都不能认识。 选择器前缀法（即选择器 Hack）：例如 IE6 能识别 *html .class{}，IE7 能识别 *+html .class{} 或者 *:first-child+html .class{}。 css hack 书写顺序，一般是将适用范围广、被识别能力强的 CSS 定义在前面。 条件注释法语法：123&lt;!-- [if &lt;keywords&gt;? IE &lt;version&gt; ?]&gt;HTML 代码块&lt;![endif]--&gt; 取值：&lt;keywords&gt;if 条件共包含 6 种选择方式：是否、大于、大于或等于、小于、小于或等于、非指定版本是否：指定是否 IE 或 IE 某个版本。关键字：空大于：选择大鱼指定版本的 IE 版本。关键字：gt大于或等于：选择大于或等于指定版本的 IE 版本。关键字：gte小于：选择小于指定版本的IE版本。关键字：lt小于或等于：选择小于或等于指定版本的IE版本。关键字：lte非指定版本：选择除指定版本外的所有IE版本。关键字：! 说明：用于选择 IE 浏览器及IE的不同版本 示例： 123456789101112131415161718192021222324只在IE下生效&lt;!--[if IE]&gt;这段文字只在IE浏览器显示&lt;![endif]--&gt;只在IE6下生效&lt;!--[if IE 6]&gt;这段文字只在IE6浏览器显示&lt;![endif]--&gt;只在IE6以上版本生效&lt;!--[if gte IE 6]&gt;这段文字只在IE6以上(包括)版本IE浏览器显示&lt;![endif]--&gt;只在IE8上不生效&lt;!--[if ! IE 8]&gt;这段文字在非IE8浏览器显示&lt;![endif]--&gt;非IE浏览器生效&lt;!--[if !IE]&gt;这段文字只在非IE浏览器显示&lt;![endif]--&gt; 需要说明的是，IE10和11已经不支持这种条件注释法了。 CSS 属性前缀法语法：selector {?property:value?;} 取值：_：选择 IE6 及以下。连接线（中划线）（-）亦可使用，为了避免与某些带中划线的属性混淆，所以使用下划线（_）更为合适。*：选择 IE7 及以下。诸如：（+）与（#）之类的均可使用，不过业界对（*）的认知度更高。\9：选择 IE6+。\0：选择 IE8+ 和 Opera。[;property:value;];：选择 webkit 核心浏览器（Chrome,Safari）。IE7 及以下也能识别。中括号内外的 3 个分号必须保留，第一个分号前可以是任意规则或任意多个规则。[;color:#f00;]; 与 [color:#f00;color:#f00;]; 与 [margin:0;padding:0;color:#f00;]; 是等价的。生效的始终是中括号内的最后一条规则，所以通常选用第一种写法最为简洁。 说明：选择不同的浏览器及版本尽可能减少对 CSS Hack 的使用。Hack 有风险，谨慎使用。一些 CSS Hack 由于浏览器存在交叉认识，所以需要通过层层覆盖的方式来实现对不同浏览器进行 Hack 的。如下面这个例子：12345.test&#123; color:#090\9; /* For IE8+ */ *color:#f00; /* For IE7 and earlier */ _color:#ff0; /* For IE6 and earlier */&#125; 上述 Hack 均需运行在标准模式下，若在怪异模式下运行，这些 Hack 将会被不同版本的 IE 相互识别，导致失效。 选择器前缀法语法：&lt;hack&gt;selector{sRules} 说明：1234* html .test&#123;color:#090;&#125; /* For IE6 and earlier */* + html .test&#123;color:#ff0;&#125; /* For IE7 */.test:lang(zh-cn)&#123;color:#f00;&#125; /* For IE8+ and not IE */.test:nth-child(1)&#123;color:#0ff;&#125; /* For IE9+ and not IE */ 上述代码中的3,4两行就是典型的利用能力来进行选择的 CSS Hack。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IE浏览器下页面样式展示混乱]]></title>
    <url>%2F2017%2F05%2F14%2FIE%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%8B%E9%A1%B5%E9%9D%A2%E6%A0%B7%E5%BC%8F%E6%B7%B7%E4%B9%B1%2F</url>
    <content type="text"><![CDATA[问 题 描 述今天敲码的时候碰到一个问题，相同的代码，在火狐上呈现出来的样式完全没问题，但是用IE浏览器打开时样式就会变得乱七八糟。 原 因用IE开发者工具看了一下前端脚本发现，代码里多嵌套了一个表单。 解 决 方 法删掉之后发现问题解决了。 秉着知其然也要知其所以然的态度（手动认真脸），果断百度了一波，原来：是IE浏览器和火狐浏览器的兼容性问题以及JS加载的性能问题，火狐支持的是W3C标准，可能我们写的JS代码是标准的代码，而ie并不兼容该标准代码（IE一直把自己标准作为全世界的标准你懂得。。。），而且在JS执行效率和CSS的渲染效率方面火狐要比IE表现的出色一些，因此一开始加载的时候IE出现样式混乱也就不足为怪了。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Packet for query is too large (xxxx xxxx)]]></title>
    <url>%2F2017%2F04%2F02%2FPacket%20for%20query%20is%20too%20large%20(xxxx%20%20xxxx)%2F</url>
    <content type="text"><![CDATA[问 题 描 述控制台错误提示： 1ERROR org.hibernate.engine.jdbc.spi.SqlExceptionHelper -Packet for query is too large (1313 &gt; 1024). You can change this value on the server by setting the max_allowed_packet’ variable. 原 因由于MySQL配置文件里的一个系统参数：max_allowed_packet其默认值为1048576(1M)，因此，数据量过大的插入或者更新会受到max_allowed_packet参数的限制，导致写入或者更新失败。 解 决 方 法第一种方法：由于我使用的是windows系统，因此，找到MySQL的安装目录，打开其中的my.ini文件（linux系统下为my.cnf），搜索找到“max_allowed_packet = 1M”这句话，有可能没有，需要自己添加。找到后将1M改为20M，保存配置文件，然后通过windows系统的服务功能restart MySQL服务即可解决。 第二种方法： 通过navicat数据库管理工具来查看修改。通过查询的方式，键入下列脚本1show VARIABLES like &apos;%max_allowed_packet%&apos; 然后执行，就可以看到。然后修改Value属性值为20M保存，然后重启MySQL服务即可解决。这里需要注意的是，20M必须写成字节的形式，20M=20971520。]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[npm 全面介绍]]></title>
    <url>%2F2017%2F03%2F10%2Fnpm%2F</url>
    <content type="text"><![CDATA[什么是 NPMnpm 之于 Node.js ，就像 pip 之于 Python， gem 之于 Ruby， pear 之于 PHP 。 npm 是 Node.js 官方提供的包管理工具，他已经成了 Node.js 包的标准发布平台，用于 Node.js 包的发布、传播、依赖控制。npm 提供了命令行工具，使你可以方便地下载、安装、升级、删除包，也可以让你作为开发者发布并维护包。 为什么要使用 NPMnpm 是随同 Node.js 一起安装的包管理工具，能解决 Node.js 代码部署上的很多问题，常见的场景有以下几种： 允许用户从 npm 服务器下载别人编写的第三方包到本地使用。 允许用户从 npm 服务器下载并安装别人编写的命令行程序到本地使用。 允许用户将自己编写的包或命令行程序上传到 npm 服务器供别人使用。 npm 的背后，是基于 couchdb 的一个数据库，详细记录了每个包的信息，包括作者、版本、依赖、授权信息等。它的一个很重要的作用就是：将开发者从繁琐的包管理工作（版本、依赖等）中解放出来，更加专注于功能的开发。 如何使用 NPM安装npm 不需要单独安装。在安装 Node 的时候，会连带一起安装 npm 。但是，Node 附带的 npm 可能不是最新版本，最后用下面的命令，更新到最新版本。1$ sudo npm install npm@latest -g 如果是 Window 系统使用以下命令即可：1npm install npm -g 也就是使用 npm 安装自己。之所以可以这样，是因为 npm 本身与 Node 的其他模块没有区别。 然后，运行下面的命令，查看各种信息。1234567891011# 查看 npm 命令列表$ npm help# 查看各个命令的简单用法$ npm -l# 查看 npm 的版本$ npm -v# 查看 npm 的配置$ npm config list -l 使用npm initnpm init 用来初始化生成一个新的 package.json 文件。它会向用户提问一系列问题，如果你觉得不用修改默认配置，一路回车就可以了。如果使用了 -f（代表force）、-y（代表yes），则跳过提问阶段，直接生成一个新的 package.json 文件。1$ npm init -y npm setnpm set 用来设置环境变量1234$ npm set init-author-name 'Your name'$ npm set init-author-email 'Your email'$ npm set init-author-url 'http://yourdomain.com'$ npm set init-license 'MIT' 上面命令等于为 npm init 设置了默认值，以后执行 npm init 的时候，package.json 的作者姓名、邮件、主页、许可证字段就会自动写入预设的值。这些信息会存放在用户主目录的 ~/.npmrc文件，使得用户不用每个项目都输入。如果某个项目有不同的设置，可以针对该项目运行 npm config。 npm infonpm info 命令可以查看每个模块的具体信息。比如，查看 underscore 模块的信息。1$ npm info underscore 上面命令返回一个 JavaScript 对象，包含了 underscore 模块的详细信息。这个对象的每个成员，都可以直接从 info 命令查询。12345$ npm info underscore description$ npm info underscore homepage$ npm info underscore version npm searchnpm search 命令用于搜索 npm 仓库，它后面可以跟字符串，也可以跟正则表达式。1$ npm search &lt;搜索词&gt; npm listnpm list 命令以树形结构列出当前项目安装的所有模块，以及它们依赖的模块。1234567$ npm list# 加上 global 参数，会列出全局安装的模块$ npm list -global# npm list 命令也可以列出单个模块$ npm list underscore npm install使用 npm 安装包的命令格式为：npm [install/i] [package_name] 本地模式和全局模式npm 在默认情况下会从 http://npmjs.org 搜索或下载包，将包安装到当前目录的 node_modules 子目录下。如果你熟悉 Ruby 的 gem 或者 Python 的 pip，你会发现 npm 与它们的行为不同，gem 或 pip 总是以全局模式安装，使包可以供所有的程序使用，而 npm 默认会把包安装到当前目录下。这反映了 npm 不同的设计哲学。如果把包安装到全局，可以提供程序的重复利用程度，避免同样的内容的多分副本，但坏处是难以处理不同的版本依赖。如果把包安装到当前目录，或者说本地，则不会有不同程序依赖不同版本的包的冲突问题，同时还减轻了包作者的 API 兼容性压力，但缺陷则是同一个包可能会被安装许多次。 我们在使用 supervisor 的时候使用了 npm install -g supervisor 命令，就是以全局模式安装 supervisor 。 这里注意一点的就是，supervisor 必须安装到全局，如果你不安装到全局，错误命令会提示你安装到全局。如果不想安装到默认的全局，也可以自己修改全局路径到当前路径 npm config set prefix &quot;路径&quot; 安装完以后就可以用 supervisor 来启动服务了。supervisor 可以帮助你实现这个功能，它会监视你对代码的驱动，并自动重启 Node.js 。 一般来说，全局安装只适用于工具模块，比如 eslint 和 gulp 。关于使用全局模式，多数时候并不是因为许多程序都有可能用到了它，为了减少多重副本而使用全局模式，而是因为本地模式不会注册 PATH 环境变量。“本地安装”指的是将一个模块下载到当前项目的 node_modules 子目录，然后只有在项目目录之中，才能调用这个模块。 本地模式和全局模式的特点如下： 模式 可通过 require 使用 注册 PATH 本地模式 是 否 全局模式 否 是 123456# 本地安装$ npm install &lt;package name&gt;# 全局安装$ sudo npm install -global &lt;package name&gt;$ sudo npm install -g &lt;package name&gt; npm install 也支持直接输入 Github 代码库地址。12$ npm install git://github.com/package/path.git$ npm install git://github.com/package/path.git#0.1.0 安装之前，npm install 会先检查，node_modules 目录之中是否已经存在指定模块。如果存在，就不再重新安装了，即使远程仓库已经有了一个新版本，也是如此。 如果你希望，一个模块不管是否安装过， npm 都要强制重新安装，可以使用 -f 或 –force 参数。1$ npm install &lt;packageName&gt; --force 安装不同版本install 命令总是安装模块的最新版本，如果要安装模块的特定版本，可以在模块名后面加上 @ 和版本号。123$ npm install sax@latest$ npm install sax@0.1.1$ npm install sax@"&gt;=0.1.0 &lt;0.2.0" install 命令可以使用不同参数，指定所安装的模块属于哪一种性质的依赖关系，即出现在 packages.json 文件的哪一项中。 –save：模块名将被添加到 dependencies，可以简化为参数-S。–save-dev：模块名将被添加到 devDependencies，可以简化为参数-D。 12345$ npm install sax --save$ npm install node-tap --save-dev# 或者$ npm install sax -S$ npm install node-tap -D dependencies 依赖这个可以说是我们 npm 核心一项内容，依赖管理，这个对象里面的内容就是我们这个项目所依赖的 js 模块包。下面这段代码表示我们依赖了 markdown-it 这个包，版本是 ^8.1.0 ，代表最小依赖版本是 8.1.0 ，如果这个包有更新，那么当我们使用 npm install 命令的时候，npm 会帮我们下载最新的包。当别人引用我们这个包的时候，包内的依赖包也会被下载下来。123"dependencies": &#123; "markdown-it": "^8.1.0"&#125; devDependencies 开发依赖在我们开发的时候会用到的一些包，只是在开发环境中需要用到，但是在别人引用我们包的时候，不会用到这些内容，放在 devDependencies 的包，在别人引用的时候不会被 npm 下载。1234567891011"devDependencies": &#123; "autoprefixer": "^6.4.0",0", "babel-preset-es2015": "^6.0.0", "babel-preset-stage-2": "^6.0.0", "babel-register": "^6.0.0", "webpack": "^1.13.2", "webpack-dev-middleware": "^1.8.3", "webpack-hot-middleware": "^2.12.2", "webpack-merge": "^0.14.1", "highlightjs": "^9.8.0"&#125; 当你有了一个完整的 package.json 文件的时候，就可以让人一眼看出来，这个模块的基本信息，和这个模块所需要依赖的包。我们可以通过 npm install 就可以很方便的下载好这个模块所需要的包。 npm install 默认会安装 dependencies 字段和 devDependencies 字段中的所有模块，如果使用 –production 参数，可以只安装 dependencies 字段的模块。123$ npm install --production# 或者$ NODE_ENV=production npm install 一旦安装了某个模块，就可以在代码中用 require 命令加载这个模块。12var backbone = require('backbone')console.log(backbone.VERSION) npm runnpm 不仅可以用于模块管理，还可以用于执行脚本。package.json 文件有一个 scripts 字段，可以用于指定脚本命令，供 npm 直接调用。package.json123456789101112&#123; "name": "myproject", "devDependencies": &#123; "jshint": "latest", "browserify": "latest", "mocha": "latest" &#125;, "scripts": &#123; "lint": "jshint **.js", "test": "mocha test/" &#125;&#125; scripts 脚本顾名思义，就是一些脚本代码，可以通过 npm run script-key 来调用，例如在这个 package.json 的文件夹下使用 npm run dev 就相当于运行了 node build/dev-server.js 这一段代码。使用 scripts 的目的就是为了把一些要执行的代码合并到一起，使用 npm run 来快速的运行，方便省事。npm run 是 npm run-script 的缩写，一般都使用前者，但是后者可以更好的反应这个命令的本质。 123456789// 脚本"scripts": &#123; "dev": "node build/dev-server.js", "build": "node build/build.js", "docs": "node build/docs.js", "build-docs": "npm run docs &amp; git checkout gh-pages &amp; xcopy /sy dist\\* . &amp; git add . &amp; git commit -m 'auto-pages' &amp; git push &amp; git checkout master", "build-publish": "rmdir /S /Q lib &amp; npm run build &amp;git add . &amp; git commit -m auto-build &amp; npm version patch &amp; npm publish &amp; git push", "lint": "eslint --ext .js,.vue src"&#125; npm run 如果不加任何参数，直接运行，会列出 package.json 里面所有可以执行的脚本命令。npm 内置了两个命令简写， npm test 等同于执行 npm run test，npm start 等同于执行 npm run start。 1"build": "npm run build-js &amp;&amp; npm run build-css" 上面的写法是先运行 npm run build-js ，然后再运行 npm run build-css ，两个命令中间用 &amp;&amp; 连接。如果希望两个命令同时平行执行，它们中间可以用 &amp; 连接。 写在 scripts 属性中的命令，也可以在 node_modules/.bin 目录中直接写成 bash 脚本。下面是一个 bash 脚本。1234#!/bin/bashcd site/mainbrowserify browser/main.js | uglifyjs -mc &gt; static/bundle.js 假定上面的脚本文件名为 build.sh ，并且权限为可执行，就可以在 scripts 属性中引用该文件。1"build-js": "bin/build.sh" pre- 和 post- 脚本npm run 为每条命令提供了 pre- 和 post- 两个钩子（hook）。以 npm run lint 为例，执行这条命令之前，npm 会先查看有没有定义 prelint 和 postlint 两个钩子，如果有的话，就会先执行 npm run prelint，然后执行 npm run lint，最后执行 npm run postlint。12345678910111213&#123; "name": "myproject", "devDependencies": &#123; "eslint": "latest" "karma": "latest" &#125;, "scripts": &#123; "lint": "eslint --cache --ext .js --ext .jsx src", "test": "karma start --log-leve=error karma.config.js --single-run=true", "pretest": "npm run lint", "posttest": "echo 'Finished running tests'" &#125;&#125; 上面代码是一个 package.json 文件的例子。如果执行 npm test，会按下面的顺序执行相应的命令。 pretest test posttest 如果执行过程出错，就不会执行排在后面的脚本，即如果 prelint 脚本执行出错，就不会接着执行 lint 和 postlint 脚本。 npm binnpm bin 命令显示相对于当前目录的，Node 模块的可执行脚本所在的目录（即 .bin 目录）。123# 项目根目录下执行$ npm bin./node_modules/.bin 创建全局链接npm 提供了一个有趣的命令 npm link，它的功能是在本地包和全局包之间创建符号链接。我们说过使用全局模式安装的包不能直接通过 require 使用。但通过 npm link 命令可以打破这一限制。举个例子，我们已经通过 npm install -g express 安装了 express，这时在工程的目录下运行命令：npm link express ./node_modules/express -&gt; /user/local/lib/node_modules/express我们可以在 node_modules 子目录中发现一个指向安装到全局的包的符号链接。通过这种方法，我们就可以把全局包当做本地包来使用了。除了将全局的包链接到本地以外，使用 npm link 命令还可以将本地的包链接到全局。使用方法是在包目录（package.json 所在目录）中运行 npm link 命令。如果我们要开发一个包，利用这种方法可以非常方便地在不同的工程间进行测试。 创建包包是在模块基础上更深一步的抽象，Node.js 的包类似于 C/C++ 的函数库或者 Java、.Net 的类库。它将某个独立的功能封装起来，用于发布、更新、依赖管理和版本控制。Node.js 根据 CommonJS 规范实现了包机制，开发了 npm 来解决包的发布和获取需求。Node.js 的包是一个目录，其中包含了一个 JSON 格式的包说明文件 package.json。严格符合 CommonJS 规范的包应该具备以下特征：。package.json 必须在包的顶层目录下；。二进制文件应该在 bin 目录下；。JavaScript 代码应该在 lib 目录下；。文档应该在 doc 目录下；。单元测试应该在 test 目录下。 Node.js 对包的要求并没有这么严格，只要顶层目录下有 package.json，并符合一些规范即可。当然为了提高兼容性，我们还是建议你在制作包的时候，严格遵守 CommonJS 规范。 我们也可以把文件夹封装为一个模块，即所谓的包。包通常是一些模块的集合，在模块的基础上提供了更高层的抽象，相当于提供了一些固定接口的函数库。通过定制 package.json，我们可以创建更复杂，更完善，更符合规范的包用于发布。 Node.js 在调用某个包时，会首先检查包中 packgage.json 文件的 main 字段，将其作为包的接口模块，如果 package.json 或 main 字段不存在，会尝试寻找 index.js 或 index.node 作为包的接口。 package.json 是 CommonJS 规定的用来描述包的文件，完全符合规范的 package.json 文件应该含有以下字段：name: 包的名字，必须是唯一的，由小写英文字母、数字和下划线组成，不能包含空格。description: 包的简要说明。version: 符合语义化版本识别规范的版本字符串。keywords: 关键字数组，通常用于搜索。maintainers: 维护者数组，每个元素要包含 name 、email(可选)、web(可选)字段。contributors: 贡献者数组，格式与 maintainers 相同。包的作者应该是贡献者数组的第一个元素。bugs: 提交 bug 的地址，可以是网址或者电子邮件地址。licenses: 许可证数组，每个元素要包含 type（许可证的名称）和 url（链接到许可证文本的地址）字段。repositories: 仓库托管地址数组，每个元素要包含 type（仓库的类型，如 git）、URL（仓库的地址）和 path（相对于仓库的路径，可选）字段。dependencies: 包的依赖，一个关联数组，由包名称和版本号组成。 包的发布通过使用 npm init 可以根据交互式回答产生一个符合标准的 package.json。创建一个 index.js 作为包的接口,一个简单的包就制作完成了。在发布前,我们还需要获得一个账号用于今后维护自己的包,使用 npm adduser 根据提示完成账号的创建完成后可以使用 npm whoami 检测是否已经取得了账号。接下来,在 package.json 所在目录下运行 npm publish，稍等片刻就可以完成发布了，打开浏览器，访问 http://search.npmjs.org/ 就可以找到自己刚刚发布的包了。现在我们可以在世界的任意一台计算机上使用 npm install neveryumodule 命令来安装它。如果你的包将来有更新,只需要在 package.json 文件中修改 version 字段,然后重新使用 npm publish 命令就行了。如果你对已发布的包不满意，可以使用 npm unpublish 命令来取消发布。 需要说明的是：json 文件不能有注释 参考链接http://javascript.ruanyifeng.com/nodejs/npm.html 常用命令npm version 查看npm和node的版本npm list –depth=0 [-g] 查看[全局]安装的包npm root [-g] 查看[全局的]包的安装路径]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[主键与索引的区别]]></title>
    <url>%2F2017%2F03%2F08%2F%E4%B8%BB%E9%94%AE%E4%B8%8E%E7%B4%A2%E5%BC%95%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[问 题 一什么是主键？什么是索引？ 主键是表中的一个或多个字段，它的值用于惟一地标识表中的某一条记录.且不能为空; 索引是对数据库表中一列或多列的值进行排序的一种结构，只有当经常查询索引列中的数据时，才需要在表上创建索引，使用索引可快速访问数据库表中的特定信息。 索引占用磁盘空间，并且降低添加、删除和更新行的速度。当然索引也有好处就是查询速度快，它利还是大于弊的所以请慎重使用索引。 比如：一个学生表（t_stu ）有1000条数据，给它id列建个主键和索引， 你想查询id=1000；的这条信息，如果没有索引，它就一条一条的比对查找，系统运行1000次才找到，要是创建了索引，你查询id=1000的这条信息，系统只运行一次就找到了。 问 题 二索引可以建在任何一个字段上吗？ 原则上索引可以加在任何字段，不过有的字段不需要加索引，或者说，加了反而不好。 建立索引常用的规则如下：1、表的主键、外键必须有索引；2、数据量超过300的表应该有索引；3、经常与其他表进行连接的表，在连接字段上应该建立索引；4、经常出现在Where子句中的字段，特别是大表的字段，应该建立索引；5、索引应该建在选择性高的字段上；6、索引应该建在小字段上，对于大的文本字段甚至超长字段，不要建索引；7、复合索引的建立需要进行仔细分析；尽量考虑用单字段索引代替：8、频繁进行数据操作的表，不要建立太多的索引；9、删除无用的索引，避免对执行计划造成负面影响；以上是一些普遍的建立索引时的判断依据。一言以蔽之，索引的建立必须慎重，对每个索引的必要性都应该经过仔细分析，要有建立的依据。因为太多的索引与不充分、不正确的索引对性能都毫无益处：在表上建立的每个索引都会增加存储开销，索引对于插入、删除、更新操作也会增加处理上的开销。另外，过多的复合索引，在有单字段索引的情况下，一般都是没有存在价值的；相反，还会降低数据增加删除时的性能，特别是对频繁更新的表来说，负面影响更大。 问 题 三一般索引都建在主键上表示唯一索引吗？只要建在主键上的索引就自动成为唯一索引吗？ 索引建在主键上就是唯一索引，但是唯一索引不一定建在主键上，因为唯一索引可以有多个。主键与索引的区别如下： 主键是一种约束，唯一索引是一种索引，两者在本质上是不同的。 主键创建后一定包含一个唯一性索引，唯一性索引并不一定就是主键。 唯一性索引列允许空值，而主键列不允许为空值。 主键列在创建时，已经默认不为空值 + 唯一索引了。 主键可以被其他表引用为外键，而唯一索引不能。 一个表最多只能创建一个主键，但可以创建多个唯一索引。 主键更适合那些不容易更改的唯一标识，如自动递增列、身份证号等。 建在主键上的索引就是唯一索引。 问 题 四mysql 如何创建索引 1.添加PRIMARY KEY（主键索引）mysql&gt;ALTER TABLE ‘table_name’ ADD PRIMARY KEY ( ‘column’ )2.添加UNIQUE(唯一索引)mysql&gt;ALTER TABLE ‘table_name’ ADD UNIQUE (‘column’)3.添加INDEX(普通索引)mysql&gt;ALTER TABLE ‘table_name’ ADD INDEX index_name ( ‘column’ )4.添加FULLTEXT(全文索引)mysql&gt;ALTER TABLE ‘table_name’ ADD FULLTEXT ( ‘column’)5.添加多列索引mysql&gt;ALTER TABLE ‘table_name’ ADD INDEX index_name ( ‘column1’, ‘column2’, ‘column3’ ) 下面是更加详细的方法 MySQL中可以使用alter table这个SQL语句来为表中的字段添加索引。 使用alter table语句来为表中的字段添加索引的基本语法是：ALTER TABLE &lt;表名&gt; ADD INDEX (&lt;字段&gt;); 我们来尝试为test中t_name字段添加一个索引。 mysql&gt; alter table test add index(t_name);Query OK, 0 rows affected (0.17 sec)Records: 0 Duplicates: 0 Warnings: 0 执行成功后，我们来看看结果。 mysql&gt; describe test;+————+————-+——+—–+———+——-+| Field | Type | Null | Key | Default | Extra |+————+————-+——+—–+———+——-+| t_id | int(11) | YES | | NULL | || t_name | varchar(50) | NO | MUL | NULL | || t_password | char(32) | YES | | NULL | || t_birth | date | YES | | NULL | |+————+————-+——+—–+———+——-+4 rows in set (0.00 sec) 结果可以看出，t_name字段的Key这一栏由原来的空白变成了MUL。这个MUL是什么意思呢？简单解释一下：如果Key是MUL，那么该列的值可以重复，该列是一个非唯一索引的前导列(第一列)或者是一个唯一性索引的组成部分但是可以含有空值NULL。 问 题 五Oracle如何创建索引？ 当我们在某本书中查找特定的章节内容时，可以先从书的目录着手，找到该章节所在的页码，然后快速的定位到该页。这种做法的前提是页面编号是有序的。如果页码无序，就只能从第一页开始，一页页的查找了。 数据库中索引(Index)的概念与目录的概念非常类似。如果某列出现在查询的条件中，而该列的数据是无序的，查询时只能从第一行开始一行一行的匹配。创建索引就是对某些特定列中的数据排序，生成独立的索引表。在某列上创建索引后，如果该列出现在查询条件中，Oracle会自动的引用该索引，先从索引表中查询出符合条件记录的ROWID，由于ROWID是记录的物理地址，因此可以根据ROWID快速的定位到具体的记录，表中的数据非常多时，引用索引带来的查询效率非常可观。 ·如果表中的某些字段经常被查询并作为查询的条件出现时，就应该考虑为该列创建索引。 ·当从很多行的表中查询少数行时，也要考虑创建索引。有一条基本的准则是：当任何单个查询要检索的行少于或者等于整个表行数的10%时，索引就非常有用。 Oracle数据库会为表的主键和包含唯一约束的列自动创建索引。索引可以提高查询的效率，但是在数据增删改时需要更新索引，因此索引对增删改时会有负面影响。 语法结构：创建索引1CREATE [UNIQUE] INDEX index_name ON table_name(column_name[,column_name…]) 语法解析： UNIQUE:指定索引列上的值必须是唯一的。称为唯一索引。 index_name：指定索引名。 tabl_name：指定要为哪个表创建索引。 column_name：指定要对哪个列创建索引。我们也可以对多列创建索引;这种索引称为组合索引。 例子： 为EMP表的ENAME列创建创建唯一索引，为EMP表的工资列创建普通索引，把JOB列先变为小写再创建索引。 代码演示：创建索引1234567891011SQL&gt; CREATE UNIQUE INDEX UQ_ENAME_IDX ON EMP(ENAME); ①Index createdSQL&gt; CREATE INDEX IDX_SAL ON EMP(SAL); ②Index createdSQL&gt; CREATE INDEX IDX_JOB_LOWER ON EMP(LOWER(JOB)); ③Index created]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo-NexT搭建个人博客（四）]]></title>
    <url>%2F2016%2F12%2F15%2Fhexo-next-four%2F</url>
    <content type="text"><![CDATA[提示：本篇文章将介绍在使用 heox 做博客框架中的一些 bug 处理情况。 按照之前的教程介绍应该是会比较顺利的搭建好你的博客，但是难免会遇到一些意外，这个时候就要学会解决问题了。解决问题的原则是：查看 bug 信息，从上到下依次解决 bug。 下面来看几个例子： 首先这个是在 hexo clean 时报的错：提示插件 hexo-deployer-git 加载失败，想了一下，应该是上次我在移动博客目录的时候，这个模块中有一些文件名比较长的文件，系统会提示移动不过来，导致这个模块异常，很简单，文件夹中删除这个模块，重新安装即可。（或者使用 npm 来卸载这个模块，然后重新安装）如下： OK ， 现在好了，hexo clean 没有报错了。 下面，我是在执行 hexo g 的操作，同样也出现了错误： 按照图中我标注的步骤，来看一下错误信息：如 1 所示：我们首先会发现缺少模块 isarray ，但是我们查看 package.json 文件，我们的项目根本就没有引入 isarray 这个模块，我猜测这个 isarray 模块应该是某个模块的子模块 。 如 2 所示：我们顺着 at 一路往下找。 如 3 所示：发现这个 isarray 是在 hexo-generator-sitemap 里面的 ，所以我们删除这个 hexo-generator-sitemap 模块，然后重新安装这个模块。如下： OK ， 现在好了，hexo g 没有报错了。 那么，就以这两个例子来作为本次的示范吧，其实，Hexo 中的一些问题还是比较好解决的，因为它都是依赖其他模块的，定位到出问题的模块，卸载重装即可。 总结：遇到问题 bug，一定要仔细查阅错误提示信息，遵守从上往下解决的方案。]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo-NexT搭建个人博客（三）]]></title>
    <url>%2F2016%2F11%2F11%2Fhexo-next-three%2F</url>
    <content type="text"><![CDATA[经过前面两期文章，我相信你已经可以在本地建立一个非常令人满意的静态博客了，本篇文章将介绍如何将自己的静态博客部署到 gitpage 上，并托管到 github 上；以及关于 Hexo 和 NexT 中更深层次的一些问题及解方案。 一、菜单栏中标签与侧边栏中标签关联的问题 以我的博客为例，关于菜单栏中的选项 与侧边栏中的选项，由于顶部菜单栏中位置有限，所以我就想在顶部菜单栏中不显示标签这一项，于是我在 主题配置文件 中 将 menu 配置项中的标签这一个选项给注释掉了，所以它不会在菜单栏中显示，但是不代表没有这个页面，这个页面是存在的，我们只是使其不显示在顶部的菜单栏中而已，我们可以直接输入绝对地址来查看这个页面，例如：https://www.mengcarry/tags/。但是与此同时，我们发现侧边栏中的标签选项只能显示标签数量，不能点击。 这是因为侧边栏中的点击链接是根据菜单栏中对应的项来添加的，什么意思呢？就是说如果顶部菜单栏中有 标签 这一项，那么就会给侧边栏中标签这一项也添加点击链接；如果顶部菜单栏中没有标签这一项，那么就不给侧边栏中标签这一项添加点击链接，导致侧边栏中的标签项只有显示数据，不提供点击链接。 如果我们不想在菜单栏中显示标签项，但是希望侧边栏中的标签项 可以点击，该怎么做呢？ 在 主题配置文件 \themes\next\layout\_macro\sidebar.swing_ 中，将12345678&#123;% if site.tags.length &gt; 0 %&#125; &lt;div class=&quot;site-state-item site-state-tags&quot;&gt; &#123;% if theme.menu.tags %&#125;&lt;a href=&quot;&#123;&#123; url_for(theme.menu.tags) &#125;&#125;&quot;&gt;&#123;% endif %&#125; &lt;span class=&quot;site-state-item-count&quot;&gt;&#123;&#123; site.tags.length &#125;&#125;&lt;/span&gt; &lt;span class=&quot;site-state-item-name&quot;&gt;&#123;&#123; __(&apos;state.tags&apos;) &#125;&#125;&lt;/span&gt; &#123;% if theme.menu.tags %&#125;&lt;/a&gt;&#123;% endif %&#125; &lt;/div&gt;&#123;% endif %&#125; 改成：12345678&#123;% if site.tags.length &gt; 0 %&#125; &lt;div class=&quot;site-state-item site-state-tags&quot;&gt; &lt;a href=&quot;&#123;&#123; url_for(theme.menu.tags) &#125;&#125;&quot;&gt; &lt;span class=&quot;site-state-item-count&quot;&gt;&#123;&#123; site.tags.length &#125;&#125;&lt;/span&gt; &lt;span class=&quot;site-state-item-name&quot;&gt;&#123;&#123; __(&apos;state.tags&apos;) &#125;&#125;&lt;/span&gt; &lt;/a&gt; &lt;/div&gt;&#123;% endif %&#125; 同理，关于菜单栏中 归档 和 分类 的类似操作也是如此。 二、关于github屏蔽vendors ，导致页面空白的解决方案关于 Github Pages 过滤掉了 source/vendors 目录的访问，导致加载 vendor 里面的文件全部 404 ，页面大面积空白。1.在根目录添加 .nojekyll 文件。2.也可以手动将 source/vendors 目录修改成 source/lib 同时，修改主题配置文件 _config.yml ，将 _internal: vendors 改成你所修改的名字，例如 _internal: lib 。 三、关于如何获取自己的多说userid首先进入自己的帐号管理页面，点击左上自己的名字此时地址栏后面的一串数字就是你的多说 userid。 四、关于如何修改内容区域宽度Next 对内容的宽度的设定如下： 700px，当屏幕宽度 &lt; 1600px 900px，当屏幕宽度 &gt;= 1600px 移动设备下，宽度自适应 如果你需要修改内容的宽度，同样需要编辑样式文件。编辑主题的 source\css_variables\custom.styl 文件，新增变量：12345// 修改成你期望的宽度$content-desktop = 700px// 当视窗超过 1600px 后的宽度$content-desktop-large = 900px 此方法不适用于PiscesScheme，PiscesScheme编辑 themes\next\source\css\_schemes\Picses\_layout.styl 文件，更改以下 css 选项定义值：123.header &#123;width: 1150px;&#125;.container .main-inner &#123;width: 1150px;&#125;.content-wrap &#123;width: calc(100% - 260px);&#125; 五、图片模式新建博文，设置 type: &quot;picture&quot; ，使用 {\% gp x-x \%}...{\% endgp \%} 标签引用要展示的图片地址，如下所示：1234567891011121314---title: Naruto-Picturescategories: [picture]tags: [picture,naruto]date: 2016-11-02 14:36:04type: &quot;picture&quot;---&#123;% gp 5-3 %&#125;![](http://oapjp6spr.bkt.clouddn.com/18210.jpg)![](http://oapjp6spr.bkt.clouddn.com/196232.jpg)![](http://oapjp6spr.bkt.clouddn.com/224147.jpg)![](http://oapjp6spr.bkt.clouddn.com/199301.jpg)![](http://oapjp6spr.bkt.clouddn.com/213318.jpg)&#123;% endgp %&#125; 图片展示效果 {\% gp 5-3 \%}：设置图片展示效果，参考 themes\next\scripts\tags\group-pictures.js 注释示意图。5-3 的意思就是5张图片将会按照这种布局来展示，Next 提供了多张图片的多种布局，你可以随意选择。 注意点主题目前首页可以正常显示设置的图片效果，但是点击进入后显示效果丢失，所以需要修改一下文件 themes\next\source\css\_common\components\tags\group-pictures.styl 中的以下样式：123456.page-post-detail .post-body .group-picture-column &#123; // float: none; margin-top: 10px; // width: auto !important; img &#123; margin: 0 auto; &#125;&#125;]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo-NexT搭建个人博客（二）]]></title>
    <url>%2F2016%2F09%2F30%2Fhexo-next-two%2F</url>
    <content type="text"><![CDATA[本篇文章将介绍基于NexT主题下的一些扩展功能的实现。首先，我们需要明白： 在 Hexo 中有两份主要的配置文件，其名称都是 _config.yml 。其中，一份位于站点根目录下，主要包含 Hexo 本身的配置；另一份位于主题目录下，这份配置由主题作者提供，主要用于配置主题相关的选项。 我们约定，将前者称为 站点配置文件，后者称为 主题配置文件 1.设置侧栏的位置修改 主题配置文件 中 sidebar.position 的值，支持的选项有：left right目前仅 Pisces Scheme 支持 position 配置，也就是说NexT主题的侧栏位置是不能设置的，设置了也没用，反正都在右边。 2. 关于添加居中模块优秀的人，不是不合群，而是他们合群的人里面没有你代码如下：1&lt;blockquote class="blockquote-center"&gt;优秀的人，不是不合群，而是他们合群的人里面没有你&lt;/blockquote&gt; 3. 添加High一下打开博客根目录 \themes\next\layout\_partials\header.swig ，在&lt;ul&gt; ... /ul&gt; 标签之间加入以下代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150&lt;li&gt; &lt;a title="把这个链接拖到你的Chrome收藏夹工具栏中" href='javascript:(function() &#123; function c() &#123; var e = document.createElement("link"); e.setAttribute("type", "text/css"); e.setAttribute("rel", "stylesheet"); e.setAttribute("href", f); e.setAttribute("class", l); document.body.appendChild(e) &#125; function h() &#123; var e = document.getElementsByClassName(l); for (var t = 0; t &lt; e.length; t++) &#123; document.body.removeChild(e[t]) &#125; &#125; function p() &#123; var e = document.createElement("div"); e.setAttribute("class", a); document.body.appendChild(e); setTimeout(function() &#123; document.body.removeChild(e) &#125;, 100) &#125; function d(e) &#123; return &#123; height : e.offsetHeight, width : e.offsetWidth &#125; &#125; function v(i) &#123; var s = d(i); return s.height &gt; e &amp;&amp; s.height &lt; n &amp;&amp; s.width &gt; t &amp;&amp; s.width &lt; r &#125; function m(e) &#123; var t = e; var n = 0; while (!!t) &#123; n += t.offsetTop; t = t.offsetParent &#125; return n &#125; function g() &#123; var e = document.documentElement; if (!!window.innerWidth) &#123; return window.innerHeight &#125; else if (e &amp;&amp; !isNaN(e.clientHeight)) &#123; return e.clientHeight &#125; return 0 &#125; function y() &#123; if (window.pageYOffset) &#123; return window.pageYOffset &#125; return Math.max(document.documentElement.scrollTop, document.body.scrollTop) &#125; function E(e) &#123; var t = m(e); return t &gt;= w &amp;&amp; t &lt;= b + w &#125; function S() &#123; var e = document.createElement("audio"); e.setAttribute("class", l); e.src = i; e.loop = false; e.addEventListener("canplay", function() &#123; setTimeout(function() &#123; x(k) &#125;, 500); setTimeout(function() &#123; N(); p(); for (var e = 0; e &lt; O.length; e++) &#123; T(O[e]) &#125; &#125;, 15500) &#125;, true); e.addEventListener("ended", function() &#123; N(); h() &#125;, true); e.innerHTML = " &lt;p&gt;If you are reading this, it is because your browser does not support the audio element. We recommend that you get a new browser.&lt;/p&gt; &lt;p&gt;"; document.body.appendChild(e); e.play() &#125; function x(e) &#123; e.className += " " + s + " " + o &#125; function T(e) &#123; e.className += " " + s + " " + u[Math.floor(Math.random() * u.length)] &#125; function N() &#123; var e = document.getElementsByClassName(s); var t = new RegExp("\\b" + s + "\\b"); for (var n = 0; n &lt; e.length; ) &#123; e[n].className = e[n].className.replace(t, "") &#125; &#125; var e = 30; var t = 30; var n = 350; var r = 350; var i = "//7xuupy.com1.z0.glb.clouddn.com/tongxingSibel%20-%20Im%20Sorry.mp3"; var s = "mw-harlem_shake_me"; var o = "im_first"; var u = ["im_drunk", "im_baked", "im_trippin", "im_blown"]; var a = "mw-strobe_light"; var f = "//s3.amazonaws.com/moovweb-marketing/playground/harlem-shake-style.css"; var l = "mw_added_css"; var b = g(); var w = y(); var C = document.getElementsByTagName("*"); var k = null; for (var L = 0; L &lt; C.length; L++) &#123; var A = C[L]; if (v(A)) &#123; if (E(A)) &#123; k = A; break &#125; &#125; &#125; if (A === null) &#123; console.warn("Could not find a node of the right size. Please try a different page."); return &#125; c(); S(); var O = []; for (var L = 0; L &lt; C.length; L++) &#123; var A = C[L]; if (v(A)) &#123; O.push(A) &#125; &#125; &#125;)() '&gt;High一下&lt;/a&gt; &lt;/li&gt; 4. 添加最近访客在需要添加最近访客的网页对应的 markdown 文件中添加如下代码：12最近访客&lt;div class=&quot;ds-recent-visitors&quot; data-num-items=&quot;39&quot; data-avatar-size=&quot;40&quot; id=&quot;ds-recent-visitors&quot;&gt;&lt;/div&gt; 5. 鼠标点击小红心的设置 将 love.js 文件添加到 \themes\next\source\js\src 文件目录下。 找到 \themes\next\layout\_layout.swing 文件， 在文件的后面，&lt;/body&gt; 标签之前 添加以下代码：12&lt;!-- 页面点击小红心 --&gt;&lt;script type="text/javascript" src="/js/src/love.js"&gt;&lt;/script&gt; 6. 背景的设置 将 particle.js 文件添加到 \themes\next\source\js\src 文件目录下。 找到 \themes\next\layout\_layout.swing 文件， 在文件的后面，&lt;/body&gt;标签之前 添加以下代码：12&lt;!-- 背景动画 --&gt;&lt;script type="text/javascript" src="/js/src/particle.js"&gt;&lt;/script&gt; 7.修改文章内链接文本样式将链接文本设置为蓝色，鼠标划过时文字颜色加深，并显示下划线。找到文件 themes\next\source\css\_custom\custom.styl ，添加如下 css 样式：12345678.post-body p a &#123; color: #0593d3; border-bottom: none; &amp;:hover &#123; color: #0477ab; text-decoration: underline; &#125;&#125; 8. 多说评论不稳定，加载速度慢怎么办？把多说评论依赖的 embed.js 放置底部，这里需要修改的文件是 duoshuo.swig。将1(document.getElementsByTagName(&apos;head&apos;)[0] 修改成下面的代码1(document.getElementById(&apos;footer&apos;) 9. 给 Github 添加 README默认情况下，Github中每一个项目，我们希望有一份 README.md 的文件来作为项目的说明，但是我们在项目根目录下的 blog\source 目录下创建一份 README.md 文件，写好说明介绍，部署的时候，这个 README.md 会被 hexo 解析掉，而不会被解析到 Github 中去的。正确的解决方法其实很简单： 把 README.md 文件的后缀名改成 “MDOWN” 然后扔到blog/source文件夹下即可，这样 hexo 不会解析，Github 也会将其作为 MD 文件解析。 10. 给 Blog 添加 LICENSE在 主题配置文件 中的 160 行左右：12345# Creative Commons 4.0 International License.# http://creativecommons.org/# Available: by | by-nc | by-nc-nd | by-nc-sa | by-nd | by-sa | zerocreative_commons: by-nc-sa#creative_commons: 将其中第 4 行的注释放开，然后选择你想使用的 LICENSE 即可，可选项参照第 3 行。]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo-NexT搭建个人博客（一）]]></title>
    <url>%2F2016%2F09%2F03%2Fhexo-next-one%2F</url>
    <content type="text"><![CDATA[简介Hexo 是一个快速、简洁且高效的静态站点生成框架，它基于 Node.js 。 它有以下特点： 超快速度Node.js 所带来的超快生成速度，让上百个页面在几秒内瞬间完成渲染。 支持MarkdownHexo 支持 GitHub Flavored Markdown 的所有功能，甚至可以整合 Octopress 的大多数插件。 一键部署只需一条指令即可部署到Github Pages，或其他网站 丰富的插件Hexo 拥有强大的插件系统，安装插件可以让 Hexo 支持 Jade, CoffeeScript。 通过 Hexo 你可以轻松地使用 Markdown 编写文章，除了 Markdown 本身的语法之外，还可以使用 Hexo 提供的 标签插件 来快速的插入特定形式的内容。 基于 Hexo 这个优秀的博客框架，很多优秀的开发者奉献出了它们基于 Hexo 开发的主题。NexT 因其 精于心，简于形 的风格，一直被广大用户所喜爱。 安装安装 Hexo 只需几分钟时间，若你在安装过程中遇到问题或无法找到解决方式，请提交问题，我会尽力解决你的问题。 安装前提安装 Hexo 相当简单。然而在安装前，您必须检查电脑中是否已安装下列应用程序: Node.jsGit 如果您的电脑中已经安装上述必备程序，那么恭喜你！接下来只需要使用 npm 即可完成 Hexo 的安装。1$ npm install -g hexo-cli 如果你的电脑中尚未安装所需要的程序，请根据以下安装指示完成安装。 安装 Git Windows：下载安装 git 。 Download Now Mac：使用 Homebrew，MacPorts 或下载 安装程序 安装 Linux（Ubuntu，Debian）：sudo apt-get install git-core Linux（Fedora，Red Hat，CentOS）：sudo yum install git-core 安装 Node.js安装 Node.js 的最佳方式是使用 nvm。（nvm：Node Version Manager）windows 下使用 nvm 请看这里： nvm-windows ，首先需要下载安装 nvm 。 Download Nowwindows下安装完nvm以后，我们可以打开命令行中执行命令12$ nvm$ nvm install latest 执行完以后，重启命令行，执行命令 node -v ，如果出现版本号，那么 Node.js 就安装成功了。 如果没有安装成功，那可能就是墙的原因。建议下载 Node.js 直接安装。 Download Now 安装 Hexo有了 Node.js ，我们可以使用 npm 安装 Hexo。1$ npm install -g hexo-cli 安装 Hexo 完成后，我们首先需要为我们的项目创建一个指定文件夹（例如我在 D 盘目录下创建了一个文件夹 blog 。D:\blog ），在指定文件夹中执行下列命令， Hexo 将会在指定文件夹中新建所需要的文件。1$ hexo init 等待安装，安装完成后，指定文件夹 的目录如下：12345678.├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── 我们继续执行命令12$ hexo g$ hexo s --debug Hexo 将 source 文件夹中除 _posts 文件夹之外，开头命名为 _(下划线)的文件 / 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件夹会被拷贝过去。这个时候，我们在浏览器中访问 http://localhost:4000/ ，就可以看到基于 Hexo 的默认主题的原型。 安装 NexT 主题下载 NexT 主题依旧是在当前目录下，使用 Git checkout 代码：1$ git clone https://github.com/iissnan/hexo-theme-next themes/next 等待下载完成。 在 Hexo 中有两份主要的配置文件，其名称都是 _config.yml 。其中，一份位于站点根目录下，主要包含 Hexo 本身的配置；另一份位于主题目录下，这份配置由主题作者提供，主要用于配置主题相关的选项。 我们约定，将前者称为 站点配置文件，后者称为 主题配置文件 启用 NexT 主题打开 站点配置文件 ，找到 theme 字段，并将其值更改为 next 。到此， NexT 主题安装完成。下一步我们将验证主题是否正确启用。在切换主题之后、验证之前，我们最好使用 hexo clean 来清除 Hexo 的缓存。 验证主题首先启动 Hexo 本地站点，并开启调试模式（即加上 --debug），整个命令是 hexo s --debug。在服务启动的过程，注意观察命令行输出是否有任何异常信息。当命令行输出中提示： 1INFO Hexo is running at http://0.0.0.0:4000/. Press Ctrl+C to stop. 此时即可使用浏览器访问 http://localhost:4000/ ，检查站点是否正确运行。 当你看到站点的外观与下图所示类似时即说明你已成功安装 NexT 主题。这是 NexT 默认的 Scheme —— Muse现在，我们已经成功安装并启用了 NexT 主题。关于更多基本操作和基础知识，请查阅 Hexo 与 NexT 官方文档. 总结本地调试步骤三部曲：123$ hexo clean$ hexo g$ hexo s --debug 这种带 debug 的运行，如果出现错误，可以在命令行中看到错误提示信息。 部署步骤三部曲：123$ hexo clean$ hexo g$ hexo d 当然在部署之前，需要先配置好配置文件中的 deploy。 常用命令1234567$ hexo new "postName" #新建文章$ hexo new page "pageName" # 新建页面$ hexo generate # 生成静态页面至public目录$ hexo server # 开启预览访问端口(默认端口4000，'ctrl+c'关闭server)$ hexo deploy # 项目部署$ hexo help # 查看帮助$ hexo version # 查看Hexo的版本 简写命令1234$ hexo new == hexo n$ hexo generate == hexo g$ hexo server == hexo s$ hexo deploy == hexo d 常见问题1在 hexo 的配置和设置文件中，在冒号后面没留空格会导致出问题：错误的设置：123author:Neveryuemail:react.dong.yu@gmail.comlanguage:zh-CN 正确的设置：123author: Neveryuemail: react.dong.yu@gmail.comlanguage: zh-CN 常见问题2关于 Git 提交中用户名和 Email 的设置12git config --global user.name &quot;Your name&quot;git config --global user.email &quot;Your email&quot; 常见问题3Hexo 中的图标使用的是 Font Awesome ，所以，我们的博客已经自带了 Font Awesome 中的所有图标，基本可以满足我们的所有需求，我们可以去 Font Awesome 中查找我们想要使用的图标。 &lt;i class=&quot;fa fa-github&quot;&gt;&lt;/i&gt; &lt;i class=&quot;fa fa-github fa-lg&quot;&gt;&lt;/i&gt; &lt;i class=&quot;fa fa-github fa-2x&quot;&gt;&lt;/i&gt;]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ajax往后台传递参数时页面状态一直为400 bad request]]></title>
    <url>%2F2016%2F03%2F02%2Fajax%E5%BE%80%E5%90%8E%E5%8F%B0%E4%BC%A0%E9%80%92%E5%8F%82%E6%95%B0%E6%97%B6%E9%A1%B5%E9%9D%A2%E7%8A%B6%E6%80%81%E4%B8%80%E7%9B%B4%E4%B8%BA400%20bad%20request%2F</url>
    <content type="text"><![CDATA[问 题 描 述今天工作时碰到一个坑爹的问题，在用ajax向后台传递参数时，页面一直卡住不动，后台不报错，用火狐浏览器的firebug可以看到，页面一直显示错误400 bad request。 原 因前台页面要往后台传递的VO的一个实体bean里面的两个字段名称与前台form表单序列化之后的name名称不匹配。 解 决 方 法将前台表单里要传递的参数name属性值修改成和实体bean的字段名称一致。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA-API解释说明]]></title>
    <url>%2F2015%2F09%2F01%2FjavaAPI%2F</url>
    <content type="text"><![CDATA[问 题 : 什么是JavaAPI?Java-API分为两个意思； 一种是应用程序接口，API（Application Programming Interface,应用程序编程接口）是一些预先定义的函数，目的是提供应用程序与开发人员基于某软件或硬件得以访问一组例程的能力，而又无需访问源码，或理解内部工作机制的细节。 另外一种意思就是本文所说的是一种对API应用程序接口的解释、说明，便于我们使用里面的接口、类和方法。JAVA API文档提供了很多官方的介绍和类、方法、变量的解释。一般很系统，涉及所有的方面，如果开发人员对正在使用的类不熟悉，想查看类里面的变量或者方法，就可以打开JavaAPI文档进行阅读和查看。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
</search>
