<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Hexo-NexT搭建个人博客（五）]]></title>
    <url>%2F2017%2F07%2F15%2Fhexo-next-five%2F</url>
    <content type="text"><![CDATA[在这之前，我写过四篇关于 Hexo + NexT 构建博客的文章。=》【传送门】 本文将会介绍一些自定义的功能。相较于之前主要是修改配置文件中的内容，现在更多的是动手改源码来实现功能，而且还能帮你搞懂一些 Hexo NexT 的源码。如果你能弄懂源码的一些流程和逻辑，那么，你将能更好的来实现自己的一些想法。 文章封面文章封面的意思就是：在博客首页的时候会显示文章的封面图片，进入这篇文章的详细页面后，将不显示这张图片。 如果想添加文章封面的话，需要添加一个字段属性：summary_img，summary_img 的值是图片的路径。 例如：12345678---title: CSS 各种Hack手段date: 2017-06-25 03:25:24categories: 前端tags: [CSS]comments: falsesummary_img: /images/css-hack-1.png--- 具体实现细节如下：修改 \themes\next\layout\_macro\post.swing 文件。将代码：12345&#123;% if post.summary_img %&#125; &lt;div class=&quot;out-img-topic&quot;&gt; &lt;img src=&#123;&#123; post.summary_img &#125;&#125; class=&quot;img-topic&quot;&gt; &lt;/div&gt;&#123;% endif %&#125; 添加到下图所示的位置 这样的话，就可以使用 summary_img: imageurl 来设置文章封面了。 开启了文章封面的文章，我建议将 &lt;!-- more --&gt; 放在文章内容的开头，像这样： 网页加载进度条打开 /themes/next/layout/_partials/head.swing 文件，在文件末尾添加如下代码：12&lt;!-- 网页加载条 --&gt;&lt;script src=&quot;https://neveryu.github.io/js/src/pace.min.js&quot;&gt;&lt;/script&gt; 然后，打开 /themes/source/css/_custom/custom.styl 文件，在文件末尾添加如下代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879/*网页加载条*//* This is a compiled file, you should be editing the file in the templates directory */.pace &#123; -webkit-pointer-events: none; pointer-events: none; -webkit-user-select: none; -moz-user-select: none; user-select: none;&#125;.pace-inactive &#123; display: none;&#125;.pace .pace-progress &#123; background: #1e92fb; position: fixed; z-index: 2000; top: 0; right: 100%; width: 100%; height: 3px;&#125;.pace .pace-progress-inner &#123; display: block; position: absolute; right: 0px; width: 100px; height: 100%; box-shadow: 0 0 10px #e90f92, 0 0 5px #e90f92; opacity: 1.0; -webkit-transform: rotate(3deg) translate(0px, -4px); -moz-transform: rotate(3deg) translate(0px, -4px); -ms-transform: rotate(3deg) translate(0px, -4px); -o-transform: rotate(3deg) translate(0px, -4px); transform: rotate(3deg) translate(0px, -4px);&#125;.pace .pace-activity &#123; display: block; position: fixed; z-index: 2000; top: 15px; right: 15px; width: 14px; height: 14px; border: solid 2px transparent; border-top-color: #e90f92; border-left-color: #e90f92; border-radius: 10px; -webkit-animation: pace-spinner 400ms linear infinite; -moz-animation: pace-spinner 400ms linear infinite; -ms-animation: pace-spinner 400ms linear infinite; -o-animation: pace-spinner 400ms linear infinite; animation: pace-spinner 400ms linear infinite;&#125;@-webkit-keyframes pace-spinner &#123; 0% &#123; -webkit-transform: rotate(0deg); transform: rotate(0deg); &#125; 100% &#123; -webkit-transform: rotate(360deg); transform: rotate(360deg); &#125;&#125;@-moz-keyframes pace-spinner &#123; 0% &#123; -moz-transform: rotate(0deg); transform: rotate(0deg); &#125; 100% &#123; -moz-transform: rotate(360deg); transform: rotate(360deg); &#125;&#125;@-o-keyframes pace-spinner &#123; 0% &#123; -o-transform: rotate(0deg); transform: rotate(0deg); &#125; 100% &#123; -o-transform: rotate(360deg); transform: rotate(360deg); &#125;&#125;@-ms-keyframes pace-spinner &#123; 0% &#123; -ms-transform: rotate(0deg); transform: rotate(0deg); &#125; 100% &#123; -ms-transform: rotate(360deg); transform: rotate(360deg); &#125;&#125;@keyframes pace-spinner &#123; 0% &#123; transform: rotate(0deg); transform: rotate(0deg); &#125; 100% &#123; transform: rotate(360deg); transform: rotate(360deg); &#125;&#125;/*网页加载条 END*/ 开发环境自动刷新在 Hexo-NexT搭建个人博客（一） 已经提到了本地调试三部曲：123hexo cleanhexo generatehexo server --debug 然后我在项目的 package.json 中配成了这样：1&quot;dev&quot;: &quot;hexo clean &amp;&amp; hexo generate &amp;&amp; hexo server --debug&quot;, 这样的话，我执行 npm run dev 就可以启动本地环境了，省去了前面需要分别敲三次命令的步骤。为什么可以这样写，详情看这里：npm 全面介绍npm 的一个小细节 这样还不爽，我希望在写博客的时候，按下 Ctrl + S 后能自动刷新浏览器，看到实时的效果，省去了自己手动刷新浏览器的过程，在双屏下，真的很好用，一边写一边看。具体的做法是:在项目的根目录下添加一个 gulpfile.js 文件，文件内容参看 源码，这里我就不贴了。然后安装 gulpfile.js 里面的依赖包。 gulpfile.js 里面有一个 dev-proxy 方法，会代理本地的 4000 端口，并且监听文件变化，如有变化就会自动刷新浏览器。 最后，我们的开发步骤就变成这样了：先打开一个 Terminal ，使用 npm run dev 开启本地的博客服务。然后再开一个 Terminal，使用 gulp 命令来开启监听和代理服务。 代码压缩在项目的根目录下，执行以下命令：12cnpm install gulp -gcnpm install gulp-minify-css gulp-uglify gulp-htmlmin gulp --save-dev 然后在 gulpfile.js 里面写上相关代码，详情查看 源码 。 然后执行 gulp min 就会根据 gulpfile.js 中的配置，对 public 目录中的静态资源文件进行压缩。 鼠标右键 -&gt; 查看网页源代码，可以看到已经是压缩过的。 自定义页面与目录下面介绍两种方法： 第一种方法是使用 Hexo 提供的跳过渲染配置，适用于整个目录的设置。 具体步骤，打开博客根目录_config.yml，找到其中 skip_render 配置项，这个用来配置 /source/ 中需要跳过渲染的文件或目录，例如希望跳过 /source/projects/ 里的所有文件渲染，可以配置为：1skip_render: projects/** 匹配规则是一种类似正则的规则，官方给出的参考是这个。另外在测试这个功能的时候发现，Hexo 的内部缓存不是特别好用，有时候你修改了配置但生成出来的内容不一定及时应用了新配置，最好在生成之前执行一下 hexo clean 命令，清除掉旧的生成文件和缓存。 第二种方法是给单个文件添加不应用模板的标记，适用于个别特殊文件的处理。例如我们的网站如果要使用百度统计，往往需要在根目录放一个 html 格式的验证文件，这个文件默认也会经过用主题模板渲染，避免渲染的办法就是在文件头部添加如下内容： 123---layout: false--- 这样，这个文件就不会经过模板渲染，最终发布到 /public/ 里的文件就是去掉标记后的文件的样子。 关于 categories 和 tags 页面 Cannot GET 的解决方案有同学反馈在配置文件中配置了 categories 和 tags 后依然没有 categories 和 tags 页面，提示 Cannot GET。 其实在配置了 categories 和 tags 后，还需要在 /source/ 目录下新建 categories 目录和 tags 目录，里面的要有 index.md 文件，并且文件开头不能少，也不能写错。]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS 各种Hack手段]]></title>
    <url>%2F2017%2F06%2F25%2Fcss-hack%2F</url>
    <content type="text"><![CDATA[随着浏览器的发展，css hack 技术的使用应该越来越少了，但是在某些关键时刻以及综合的WEB应用或者老项目中，可能还需要使用 css hack 技术来解决一些问题。 css hack 分类css hack 分类大致有 3 种表现形式：IE条件注释法、CSS属性前缀法以及选择器前缀法。 IE 条件注释法（即 HTML 条件注释 Hack）：针对所有IE(注：IE10+ 已经不再支持条件注释)：&lt;!--[if IE]&gt;IE浏览器显示的内容 &lt;![endif]--&gt;； 针对 IE6 及以下版本：&lt;!--[if lt IE 6]&gt;只在IE6-显示的内容 &lt;![endif]--&gt;。这类 Hack 不仅对 CSS 生效，对写在判断语句里面的所有代码都会生效。 属性前缀法（即类内部 Hack）：例如 IE6 能识别下划线 _ 和星号 *，IE7 能识别星号 *，但不能识别下划线 _，IE6~IE10 都认识 \9，但 firefox 前述三个都不能认识。 选择器前缀法（即选择器 Hack）：例如 IE6 能识别 *html .class{}，IE7 能识别 *+html .class{} 或者 *:first-child+html .class{}。 css hack 书写顺序，一般是将适用范围广、被识别能力强的 CSS 定义在前面。 条件注释法语法：123&lt;!-- [if &lt;keywords&gt;? IE &lt;version&gt; ?]&gt;HTML 代码块&lt;![endif]--&gt; 取值：&lt;keywords&gt;if 条件共包含 6 种选择方式：是否、大于、大于或等于、小于、小于或等于、非指定版本是否：指定是否 IE 或 IE 某个版本。关键字：空大于：选择大鱼指定版本的 IE 版本。关键字：gt大于或等于：选择大于或等于指定版本的 IE 版本。关键字：gte小于：选择小于指定版本的IE版本。关键字：lt小于或等于：选择小于或等于指定版本的IE版本。关键字：lte非指定版本：选择除指定版本外的所有IE版本。关键字：! 说明：用于选择 IE 浏览器及IE的不同版本 示例： 123456789101112131415161718192021222324只在IE下生效&lt;!--[if IE]&gt;这段文字只在IE浏览器显示&lt;![endif]--&gt;只在IE6下生效&lt;!--[if IE 6]&gt;这段文字只在IE6浏览器显示&lt;![endif]--&gt;只在IE6以上版本生效&lt;!--[if gte IE 6]&gt;这段文字只在IE6以上(包括)版本IE浏览器显示&lt;![endif]--&gt;只在IE8上不生效&lt;!--[if ! IE 8]&gt;这段文字在非IE8浏览器显示&lt;![endif]--&gt;非IE浏览器生效&lt;!--[if !IE]&gt;这段文字只在非IE浏览器显示&lt;![endif]--&gt; 需要说明的是，IE10和11已经不支持这种条件注释法了。运行上面示例 CSS 属性前缀法语法：selector {?property:value?;} 取值：_：选择 IE6 及以下。连接线（中划线）（-）亦可使用，为了避免与某些带中划线的属性混淆，所以使用下划线（_）更为合适。*：选择 IE7 及以下。诸如：（+）与（#）之类的均可使用，不过业界对（*）的认知度更高。\9：选择 IE6+。\0：选择 IE8+ 和 Opera。[;property:value;];：选择 webkit 核心浏览器（Chrome,Safari）。IE7 及以下也能识别。中括号内外的 3 个分号必须保留，第一个分号前可以是任意规则或任意多个规则。[;color:#f00;]; 与 [color:#f00;color:#f00;]; 与 [margin:0;padding:0;color:#f00;]; 是等价的。生效的始终是中括号内的最后一条规则，所以通常选用第一种写法最为简洁。 说明：选择不同的浏览器及版本尽可能减少对 CSS Hack 的使用。Hack 有风险，谨慎使用。一些 CSS Hack 由于浏览器存在交叉认识，所以需要通过层层覆盖的方式来实现对不同浏览器进行 Hack 的。如下面这个例子：12345.test&#123; color:#090\9; /* For IE8+ */ *color:#f00; /* For IE7 and earlier */ _color:#ff0; /* For IE6 and earlier */&#125; 上述 Hack 均需运行在标准模式下，若在怪异模式下运行，这些 Hack 将会被不同版本的 IE 相互识别，导致失效。 选择器前缀法语法：&lt;hack&gt;selector{sRules} 说明：1234* html .test&#123;color:#090;&#125; /* For IE6 and earlier */* + html .test&#123;color:#ff0;&#125; /* For IE7 */.test:lang(zh-cn)&#123;color:#f00;&#125; /* For IE8+ and not IE */.test:nth-child(1)&#123;color:#0ff;&#125; /* For IE9+ and not IE */ 上述代码中的3,4两行就是典型的利用能力来进行选择的 CSS Hack。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[npm 全面介绍]]></title>
    <url>%2F2017%2F04%2F10%2Fnpm%2F</url>
    <content type="text"><![CDATA[什么是 NPMnpm 之于 Node.js ，就像 pip 之于 Python， gem 之于 Ruby， pear 之于 PHP 。 npm 是 Node.js 官方提供的包管理工具，他已经成了 Node.js 包的标准发布平台，用于 Node.js 包的发布、传播、依赖控制。npm 提供了命令行工具，使你可以方便地下载、安装、升级、删除包，也可以让你作为开发者发布并维护包。 为什么要使用 NPMnpm 是随同 Node.js 一起安装的包管理工具，能解决 Node.js 代码部署上的很多问题，常见的场景有以下几种： 允许用户从 npm 服务器下载别人编写的第三方包到本地使用。 允许用户从 npm 服务器下载并安装别人编写的命令行程序到本地使用。 允许用户将自己编写的包或命令行程序上传到 npm 服务器供别人使用。 npm 的背后，是基于 couchdb 的一个数据库，详细记录了每个包的信息，包括作者、版本、依赖、授权信息等。它的一个很重要的作用就是：将开发者从繁琐的包管理工作（版本、依赖等）中解放出来，更加专注于功能的开发。 如何使用 NPM安装npm 不需要单独安装。在安装 Node 的时候，会连带一起安装 npm 。但是，Node 附带的 npm 可能不是最新版本，最后用下面的命令，更新到最新版本。1$ sudo npm install npm@latest -g 如果是 Window 系统使用以下命令即可：1npm install npm -g 也就是使用 npm 安装自己。之所以可以这样，是因为 npm 本身与 Node 的其他模块没有区别。 然后，运行下面的命令，查看各种信息。1234567891011# 查看 npm 命令列表$ npm help# 查看各个命令的简单用法$ npm -l# 查看 npm 的版本$ npm -v# 查看 npm 的配置$ npm config list -l 使用npm initnpm init 用来初始化生成一个新的 package.json 文件。它会向用户提问一系列问题，如果你觉得不用修改默认配置，一路回车就可以了。如果使用了 -f（代表force）、-y（代表yes），则跳过提问阶段，直接生成一个新的 package.json 文件。1$ npm init -y npm setnpm set 用来设置环境变量1234$ npm set init-author-name 'Your name'$ npm set init-author-email 'Your email'$ npm set init-author-url 'http://yourdomain.com'$ npm set init-license 'MIT' 上面命令等于为 npm init 设置了默认值，以后执行 npm init 的时候，package.json 的作者姓名、邮件、主页、许可证字段就会自动写入预设的值。这些信息会存放在用户主目录的 ~/.npmrc文件，使得用户不用每个项目都输入。如果某个项目有不同的设置，可以针对该项目运行 npm config。 npm infonpm info 命令可以查看每个模块的具体信息。比如，查看 underscore 模块的信息。1$ npm info underscore 上面命令返回一个 JavaScript 对象，包含了 underscore 模块的详细信息。这个对象的每个成员，都可以直接从 info 命令查询。12345$ npm info underscore description$ npm info underscore homepage$ npm info underscore version npm searchnpm search 命令用于搜索 npm 仓库，它后面可以跟字符串，也可以跟正则表达式。1$ npm search &lt;搜索词&gt; npm listnpm list 命令以树形结构列出当前项目安装的所有模块，以及它们依赖的模块。1234567$ npm list# 加上 global 参数，会列出全局安装的模块$ npm list -global# npm list 命令也可以列出单个模块$ npm list underscore npm install使用 npm 安装包的命令格式为：npm [install/i] [package_name] 本地模式和全局模式npm 在默认情况下会从 http://npmjs.org 搜索或下载包，将包安装到当前目录的 node_modules 子目录下。如果你熟悉 Ruby 的 gem 或者 Python 的 pip，你会发现 npm 与它们的行为不同，gem 或 pip 总是以全局模式安装，使包可以供所有的程序使用，而 npm 默认会把包安装到当前目录下。这反映了 npm 不同的设计哲学。如果把包安装到全局，可以提供程序的重复利用程度，避免同样的内容的多分副本，但坏处是难以处理不同的版本依赖。如果把包安装到当前目录，或者说本地，则不会有不同程序依赖不同版本的包的冲突问题，同时还减轻了包作者的 API 兼容性压力，但缺陷则是同一个包可能会被安装许多次。 我们在使用 supervisor 的时候使用了 npm install -g supervisor 命令，就是以全局模式安装 supervisor 。 这里注意一点的就是，supervisor 必须安装到全局，如果你不安装到全局，错误命令会提示你安装到全局。如果不想安装到默认的全局，也可以自己修改全局路径到当前路径 npm config set prefix &quot;路径&quot; 安装完以后就可以用 supervisor 来启动服务了。supervisor 可以帮助你实现这个功能，它会监视你对代码的驱动，并自动重启 Node.js 。 一般来说，全局安装只适用于工具模块，比如 eslint 和 gulp 。关于使用全局模式，多数时候并不是因为许多程序都有可能用到了它，为了减少多重副本而使用全局模式，而是因为本地模式不会注册 PATH 环境变量。“本地安装”指的是将一个模块下载到当前项目的 node_modules 子目录，然后只有在项目目录之中，才能调用这个模块。 本地模式和全局模式的特点如下： 模式 可通过 require 使用 注册 PATH 本地模式 是 否 全局模式 否 是 123456# 本地安装$ npm install &lt;package name&gt;# 全局安装$ sudo npm install -global &lt;package name&gt;$ sudo npm install -g &lt;package name&gt; npm install 也支持直接输入 Github 代码库地址。12$ npm install git://github.com/package/path.git$ npm install git://github.com/package/path.git#0.1.0 安装之前，npm install 会先检查，node_modules 目录之中是否已经存在指定模块。如果存在，就不再重新安装了，即使远程仓库已经有了一个新版本，也是如此。 如果你希望，一个模块不管是否安装过， npm 都要强制重新安装，可以使用 -f 或 –force 参数。1$ npm install &lt;packageName&gt; --force 安装不同版本install 命令总是安装模块的最新版本，如果要安装模块的特定版本，可以在模块名后面加上 @ 和版本号。123$ npm install sax@latest$ npm install sax@0.1.1$ npm install sax@"&gt;=0.1.0 &lt;0.2.0" install 命令可以使用不同参数，指定所安装的模块属于哪一种性质的依赖关系，即出现在 packages.json 文件的哪一项中。 –save：模块名将被添加到 dependencies，可以简化为参数-S。–save-dev：模块名将被添加到 devDependencies，可以简化为参数-D。 12345$ npm install sax --save$ npm install node-tap --save-dev# 或者$ npm install sax -S$ npm install node-tap -D dependencies 依赖这个可以说是我们 npm 核心一项内容，依赖管理，这个对象里面的内容就是我们这个项目所依赖的 js 模块包。下面这段代码表示我们依赖了 markdown-it 这个包，版本是 ^8.1.0 ，代表最小依赖版本是 8.1.0 ，如果这个包有更新，那么当我们使用 npm install 命令的时候，npm 会帮我们下载最新的包。当别人引用我们这个包的时候，包内的依赖包也会被下载下来。123"dependencies": &#123; "markdown-it": "^8.1.0"&#125; devDependencies 开发依赖在我们开发的时候会用到的一些包，只是在开发环境中需要用到，但是在别人引用我们包的时候，不会用到这些内容，放在 devDependencies 的包，在别人引用的时候不会被 npm 下载。1234567891011"devDependencies": &#123; "autoprefixer": "^6.4.0",0", "babel-preset-es2015": "^6.0.0", "babel-preset-stage-2": "^6.0.0", "babel-register": "^6.0.0", "webpack": "^1.13.2", "webpack-dev-middleware": "^1.8.3", "webpack-hot-middleware": "^2.12.2", "webpack-merge": "^0.14.1", "highlightjs": "^9.8.0"&#125; 当你有了一个完整的 package.json 文件的时候，就可以让人一眼看出来，这个模块的基本信息，和这个模块所需要依赖的包。我们可以通过 npm install 就可以很方便的下载好这个模块所需要的包。 npm install 默认会安装 dependencies 字段和 devDependencies 字段中的所有模块，如果使用 –production 参数，可以只安装 dependencies 字段的模块。123$ npm install --production# 或者$ NODE_ENV=production npm install 一旦安装了某个模块，就可以在代码中用 require 命令加载这个模块。12var backbone = require('backbone')console.log(backbone.VERSION) npm runnpm 不仅可以用于模块管理，还可以用于执行脚本。package.json 文件有一个 scripts 字段，可以用于指定脚本命令，供 npm 直接调用。package.json123456789101112&#123; "name": "myproject", "devDependencies": &#123; "jshint": "latest", "browserify": "latest", "mocha": "latest" &#125;, "scripts": &#123; "lint": "jshint **.js", "test": "mocha test/" &#125;&#125; scripts 脚本顾名思义，就是一些脚本代码，可以通过 npm run script-key 来调用，例如在这个 package.json 的文件夹下使用 npm run dev 就相当于运行了 node build/dev-server.js 这一段代码。使用 scripts 的目的就是为了把一些要执行的代码合并到一起，使用 npm run 来快速的运行，方便省事。npm run 是 npm run-script 的缩写，一般都使用前者，但是后者可以更好的反应这个命令的本质。 123456789// 脚本"scripts": &#123; "dev": "node build/dev-server.js", "build": "node build/build.js", "docs": "node build/docs.js", "build-docs": "npm run docs &amp; git checkout gh-pages &amp; xcopy /sy dist\\* . &amp; git add . &amp; git commit -m 'auto-pages' &amp; git push &amp; git checkout master", "build-publish": "rmdir /S /Q lib &amp; npm run build &amp;git add . &amp; git commit -m auto-build &amp; npm version patch &amp; npm publish &amp; git push", "lint": "eslint --ext .js,.vue src"&#125; npm run 如果不加任何参数，直接运行，会列出 package.json 里面所有可以执行的脚本命令。npm 内置了两个命令简写， npm test 等同于执行 npm run test，npm start 等同于执行 npm run start。 1"build": "npm run build-js &amp;&amp; npm run build-css" 上面的写法是先运行 npm run build-js ，然后再运行 npm run build-css ，两个命令中间用 &amp;&amp; 连接。如果希望两个命令同时平行执行，它们中间可以用 &amp; 连接。 写在 scripts 属性中的命令，也可以在 node_modules/.bin 目录中直接写成 bash 脚本。下面是一个 bash 脚本。1234#!/bin/bashcd site/mainbrowserify browser/main.js | uglifyjs -mc &gt; static/bundle.js 假定上面的脚本文件名为 build.sh ，并且权限为可执行，就可以在 scripts 属性中引用该文件。1"build-js": "bin/build.sh" pre- 和 post- 脚本npm run 为每条命令提供了 pre- 和 post- 两个钩子（hook）。以 npm run lint 为例，执行这条命令之前，npm 会先查看有没有定义 prelint 和 postlint 两个钩子，如果有的话，就会先执行 npm run prelint，然后执行 npm run lint，最后执行 npm run postlint。12345678910111213&#123; "name": "myproject", "devDependencies": &#123; "eslint": "latest" "karma": "latest" &#125;, "scripts": &#123; "lint": "eslint --cache --ext .js --ext .jsx src", "test": "karma start --log-leve=error karma.config.js --single-run=true", "pretest": "npm run lint", "posttest": "echo 'Finished running tests'" &#125;&#125; 上面代码是一个 package.json 文件的例子。如果执行 npm test，会按下面的顺序执行相应的命令。 pretest test posttest 如果执行过程出错，就不会执行排在后面的脚本，即如果 prelint 脚本执行出错，就不会接着执行 lint 和 postlint 脚本。 npm binnpm bin 命令显示相对于当前目录的，Node 模块的可执行脚本所在的目录（即 .bin 目录）。123# 项目根目录下执行$ npm bin./node_modules/.bin 创建全局链接npm 提供了一个有趣的命令 npm link，它的功能是在本地包和全局包之间创建符号链接。我们说过使用全局模式安装的包不能直接通过 require 使用。但通过 npm link 命令可以打破这一限制。举个例子，我们已经通过 npm install -g express 安装了 express，这时在工程的目录下运行命令：npm link express ./node_modules/express -&gt; /user/local/lib/node_modules/express我们可以在 node_modules 子目录中发现一个指向安装到全局的包的符号链接。通过这种方法，我们就可以把全局包当做本地包来使用了。除了将全局的包链接到本地以外，使用 npm link 命令还可以将本地的包链接到全局。使用方法是在包目录（package.json 所在目录）中运行 npm link 命令。如果我们要开发一个包，利用这种方法可以非常方便地在不同的工程间进行测试。 创建包包是在模块基础上更深一步的抽象，Node.js 的包类似于 C/C++ 的函数库或者 Java、.Net 的类库。它将某个独立的功能封装起来，用于发布、更新、依赖管理和版本控制。Node.js 根据 CommonJS 规范实现了包机制，开发了 npm 来解决包的发布和获取需求。Node.js 的包是一个目录，其中包含了一个 JSON 格式的包说明文件 package.json。严格符合 CommonJS 规范的包应该具备以下特征：。package.json 必须在包的顶层目录下；。二进制文件应该在 bin 目录下；。JavaScript 代码应该在 lib 目录下；。文档应该在 doc 目录下；。单元测试应该在 test 目录下。 Node.js 对包的要求并没有这么严格，只要顶层目录下有 package.json，并符合一些规范即可。当然为了提高兼容性，我们还是建议你在制作包的时候，严格遵守 CommonJS 规范。 我们也可以把文件夹封装为一个模块，即所谓的包。包通常是一些模块的集合，在模块的基础上提供了更高层的抽象，相当于提供了一些固定接口的函数库。通过定制 package.json，我们可以创建更复杂，更完善，更符合规范的包用于发布。 Node.js 在调用某个包时，会首先检查包中 packgage.json 文件的 main 字段，将其作为包的接口模块，如果 package.json 或 main 字段不存在，会尝试寻找 index.js 或 index.node 作为包的接口。 package.json 是 CommonJS 规定的用来描述包的文件，完全符合规范的 package.json 文件应该含有以下字段：name: 包的名字，必须是唯一的，由小写英文字母、数字和下划线组成，不能包含空格。description: 包的简要说明。version: 符合语义化版本识别规范的版本字符串。keywords: 关键字数组，通常用于搜索。maintainers: 维护者数组，每个元素要包含 name 、email(可选)、web(可选)字段。contributors: 贡献者数组，格式与 maintainers 相同。包的作者应该是贡献者数组的第一个元素。bugs: 提交 bug 的地址，可以是网址或者电子邮件地址。licenses: 许可证数组，每个元素要包含 type（许可证的名称）和 url（链接到许可证文本的地址）字段。repositories: 仓库托管地址数组，每个元素要包含 type（仓库的类型，如 git）、URL（仓库的地址）和 path（相对于仓库的路径，可选）字段。dependencies: 包的依赖，一个关联数组，由包名称和版本号组成。 包的发布通过使用 npm init 可以根据交互式回答产生一个符合标准的 package.json。创建一个 index.js 作为包的接口,一个简单的包就制作完成了。在发布前,我们还需要获得一个账号用于今后维护自己的包,使用 npm adduser 根据提示完成账号的创建完成后可以使用 npm whoami 检测是否已经取得了账号。接下来,在 package.json 所在目录下运行 npm publish，稍等片刻就可以完成发布了，打开浏览器，访问 http://search.npmjs.org/ 就可以找到自己刚刚发布的包了。现在我们可以在世界的任意一台计算机上使用 npm install neveryumodule 命令来安装它。如果你的包将来有更新,只需要在 package.json 文件中修改 version 字段,然后重新使用 npm publish 命令就行了。如果你对已发布的包不满意，可以使用 npm unpublish 命令来取消发布。 需要说明的是：json 文件不能有注释 参考链接http://javascript.ruanyifeng.com/nodejs/npm.html 常用命令npm version 查看npm和node的版本npm list –depth=0 [-g] 查看[全局]安装的包npm root [-g] 查看[全局的]包的安装路径]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo-NexT搭建个人博客（四）]]></title>
    <url>%2F2016%2F12%2F15%2Fhexo-next-four%2F</url>
    <content type="text"><![CDATA[提示：本篇文章将介绍在使用 heox 做博客框架中的一些 bug 处理情况。 按照之前的教程介绍应该是会比较顺利的搭建好你的博客，但是难免会遇到一些意外，这个时候就要学会解决问题了。解决问题的原则是：查看 bug 信息，从上到下依次解决 bug。 下面来看几个例子： 首先这个是在 hexo clean 时报的错：提示插件 hexo-deployer-git 加载失败，想了一下，应该是上次我在移动博客目录的时候，这个模块中有一些文件名比较长的文件，系统会提示移动不过来，导致这个模块异常，很简单，文件夹中删除这个模块，重新安装即可。（或者使用 npm 来卸载这个模块，然后重新安装）如下： OK ， 现在好了，hexo clean 没有报错了。 下面，我是在执行 hexo g 的操作，同样也出现了错误： 按照图中我标注的步骤，来看一下错误信息：如 1 所示：我们首先会发现缺少模块 isarray ，但是我们查看 package.json 文件，我们的项目根本就没有引入 isarray 这个模块，我猜测这个 isarray 模块应该是某个模块的子模块 。 如 2 所示：我们顺着 at 一路往下找。 如 3 所示：发现这个 isarray 是在 hexo-generator-sitemap 里面的 ，所以我们删除这个 hexo-generator-sitemap 模块，然后重新安装这个模块。如下： OK ， 现在好了，hexo g 没有报错了。 那么，就以这两个例子来作为本次的示范吧，其实，Hexo 中的一些问题还是比较好解决的，因为它都是依赖其他模块的，定位到出问题的模块，卸载重装即可。 总结：遇到问题 bug，一定要仔细查阅错误提示信息，遵守从上往下解决的方案。 最后要说的是： 博客源码 ， 欢迎 star]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo-NexT搭建个人博客（三）]]></title>
    <url>%2F2016%2F11%2F11%2Fhexo-next-three%2F</url>
    <content type="text"><![CDATA[经过前面两期文章，我相信你已经可以在本地建立一个非常令人满意的静态博客了，本篇文章将介绍如何将自己的静态博客部署到 gitpage 上，并托管到 github 上；以及关于 Hexo 和 NexT 中更深层次的一些问题及解方案。 一、菜单栏中标签与侧边栏中标签关联的问题 以我的博客为例，关于菜单栏中的选项 与侧边栏中的选项，由于顶部菜单栏中位置有限，所以我就想在顶部菜单栏中不显示标签这一项，于是我在 主题配置文件 中 将 menu 配置项中的标签这一个选项给注释掉了，所以它不会在菜单栏中显示，但是不代表没有这个页面，这个页面是存在的，我们只是使其不显示在顶部的菜单栏中而已，我们可以直接输入绝对地址来查看这个页面，例如：https://neveryu.github.io/tags/。但是与此同时，我们发现侧边栏中的标签选项只能显示标签数量，不能点击。 这是因为侧边栏中的点击链接是根据菜单栏中对应的项来添加的，什么意思呢？就是说如果顶部菜单栏中有 标签 这一项，那么就会给侧边栏中标签这一项也添加点击链接；如果顶部菜单栏中没有标签这一项，那么就不给侧边栏中标签这一项添加点击链接，导致侧边栏中的标签项只有显示数据，不提供点击链接。 如果我们不想在菜单栏中显示标签项，但是希望侧边栏中的标签项 可以点击，该怎么做呢？ 在 主题配置文件 \themes\next\layout\_macro\sidebar.swing_ 中，将12345678&#123;% if site.tags.length &gt; 0 %&#125; &lt;div class=&quot;site-state-item site-state-tags&quot;&gt; &#123;% if theme.menu.tags %&#125;&lt;a href=&quot;&#123;&#123; url_for(theme.menu.tags) &#125;&#125;&quot;&gt;&#123;% endif %&#125; &lt;span class=&quot;site-state-item-count&quot;&gt;&#123;&#123; site.tags.length &#125;&#125;&lt;/span&gt; &lt;span class=&quot;site-state-item-name&quot;&gt;&#123;&#123; __(&apos;state.tags&apos;) &#125;&#125;&lt;/span&gt; &#123;% if theme.menu.tags %&#125;&lt;/a&gt;&#123;% endif %&#125; &lt;/div&gt;&#123;% endif %&#125; 改成：12345678&#123;% if site.tags.length &gt; 0 %&#125; &lt;div class=&quot;site-state-item site-state-tags&quot;&gt; &lt;a href=&quot;&#123;&#123; url_for(theme.menu.tags) &#125;&#125;&quot;&gt; &lt;span class=&quot;site-state-item-count&quot;&gt;&#123;&#123; site.tags.length &#125;&#125;&lt;/span&gt; &lt;span class=&quot;site-state-item-name&quot;&gt;&#123;&#123; __(&apos;state.tags&apos;) &#125;&#125;&lt;/span&gt; &lt;/a&gt; &lt;/div&gt;&#123;% endif %&#125; 同理，关于菜单栏中 归档 和 分类 的类似操作也是如此。 二、关于High一下中的音乐多次点击重叠播放的解决方案 在之前的 High一下 的播放音乐，如果多次点击的话，音乐会重复叠加播放，严重影响听歌体验，而且只能播放一首歌。 而现在的 High一下 已经解决了这个问题，而且可以列表循环多首歌曲。我将之前的那段播放音乐的代码换了。由于代码太长了，就不在这里贴出来了。大家可以去查看我的源码：https://github.com/Neveryu/Blog。关于播放音乐的代码是在： https://github.com/Neveryu/Blog/blob/master/themes/next/layout/_partials/header.swig 中的第 60 行开始。 需要说明的是：现在的 High一下 实现了歌曲列表循环，所以，我们可以放入多首歌的链接。在代码中以数组元素的形式加入歌曲链接。1234var songs = [ &quot;http://v.65dj.com/wailian/84791c997d8c55023dad0d5690e48c28.mp3&quot;, &quot;http://7xoiki.com1.z0.glb.clouddn.com/Music-sunburst.mp3&quot;]; 三、关于github屏蔽vendors ，导致页面空白的解决方案关于 Github Pages 过滤掉了 source/vendors 目录的访问，导致加载 vendor 里面的文件全部 404 ，页面大面积空白。1.在根目录添加 .nojekyll 文件。2.也可以手动将 source/vendors 目录修改成 source/lib 同时，修改主题配置文件 _config.yml ，将 _internal: vendors 改成你所修改的名字，例如 _internal: lib 。 四、关于如何获取自己的多说userid首先进入自己的帐号管理页面，点击左上自己的名字此时地址栏后面的一串数字就是你的多说 userid。 五、关于如何修改内容区域宽度Next 对内容的宽度的设定如下： 700px，当屏幕宽度 &lt; 1600px 900px，当屏幕宽度 &gt;= 1600px 移动设备下，宽度自适应 如果你需要修改内容的宽度，同样需要编辑样式文件。编辑主题的 source\css_variables\custom.styl 文件，新增变量：12345// 修改成你期望的宽度$content-desktop = 700px// 当视窗超过 1600px 后的宽度$content-desktop-large = 900px 此方法不适用于 Pisces Scheme ， Pisces Scheme 编辑 themes\next\source\css\_schemes\Picses\_layout.styl 文件，更改以下 css 选项定义值：123.header &#123;width: 1150px;&#125;.container .main-inner &#123;width: 1150px;&#125;.content-wrap &#123;width: calc(100% - 260px);&#125; 六、图片模式新建博文，设置 type: &quot;picture&quot; ，使用 {\% gp x-x \%}...{\% endgp \%} 标签引用要展示的图片地址，如下所示：1234567891011121314---title: Naruto-Picturescategories: [picture]tags: [picture,naruto]date: 2016-11-02 14:36:04type: &quot;picture&quot;---&#123;% gp 5-3 %&#125;![](http://oapjp6spr.bkt.clouddn.com/18210.jpg)![](http://oapjp6spr.bkt.clouddn.com/196232.jpg)![](http://oapjp6spr.bkt.clouddn.com/224147.jpg)![](http://oapjp6spr.bkt.clouddn.com/199301.jpg)![](http://oapjp6spr.bkt.clouddn.com/213318.jpg)&#123;% endgp %&#125; 图片展示效果 {\% gp 5-3 \%}：设置图片展示效果，参考 themes\next\scripts\tags\group-pictures.js 注释示意图。5-3 的意思就是5张图片将会按照这种布局来展示，Next 提供了多张图片的多种布局，你可以随意选择。 注意点主题目前首页可以正常显示设置的图片效果，但是点击进入后显示效果丢失，所以需要修改一下文件 themes\next\source\css\_common\components\tags\group-pictures.styl 中的以下样式：123456.page-post-detail .post-body .group-picture-column &#123; // float: none; margin-top: 10px; // width: auto !important; img &#123; margin: 0 auto; &#125;&#125; 最后要说的是： 博客源码 ， 欢迎 star]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo-NexT搭建个人博客（二）]]></title>
    <url>%2F2016%2F09%2F30%2Fhexo-next-two%2F</url>
    <content type="text"><![CDATA[本篇文章将介绍基于NexT主题下的一些扩展功能的实现。首先，我们需要明白： 在 Hexo 中有两份主要的配置文件，其名称都是 _config.yml 。其中，一份位于站点根目录下，主要包含 Hexo 本身的配置；另一份位于主题目录下，这份配置由主题作者提供，主要用于配置主题相关的选项。 我们约定，将前者称为 站点配置文件，后者称为 主题配置文件 1.设置侧栏的位置修改 主题配置文件 中 sidebar.position 的值，支持的选项有：left right目前仅 Pisces Scheme 支持 position 配置，也就是说NexT主题的侧栏位置是不能设置的，设置了也没用，反正都在右边。 2. 关于添加居中模块优秀的人，不是不合群，而是他们合群的人里面没有你代码如下：1&lt;blockquote class="blockquote-center"&gt;优秀的人，不是不合群，而是他们合群的人里面没有你&lt;/blockquote&gt; 3. 添加High一下打开博客根目录 \themes\next\layout\_partials\header.swig ，在&lt;ul&gt; ... /ul&gt; 标签之间加入以下代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150&lt;li&gt; &lt;a title="把这个链接拖到你的Chrome收藏夹工具栏中" href='javascript:(function() &#123; function c() &#123; var e = document.createElement("link"); e.setAttribute("type", "text/css"); e.setAttribute("rel", "stylesheet"); e.setAttribute("href", f); e.setAttribute("class", l); document.body.appendChild(e) &#125; function h() &#123; var e = document.getElementsByClassName(l); for (var t = 0; t &lt; e.length; t++) &#123; document.body.removeChild(e[t]) &#125; &#125; function p() &#123; var e = document.createElement("div"); e.setAttribute("class", a); document.body.appendChild(e); setTimeout(function() &#123; document.body.removeChild(e) &#125;, 100) &#125; function d(e) &#123; return &#123; height : e.offsetHeight, width : e.offsetWidth &#125; &#125; function v(i) &#123; var s = d(i); return s.height &gt; e &amp;&amp; s.height &lt; n &amp;&amp; s.width &gt; t &amp;&amp; s.width &lt; r &#125; function m(e) &#123; var t = e; var n = 0; while (!!t) &#123; n += t.offsetTop; t = t.offsetParent &#125; return n &#125; function g() &#123; var e = document.documentElement; if (!!window.innerWidth) &#123; return window.innerHeight &#125; else if (e &amp;&amp; !isNaN(e.clientHeight)) &#123; return e.clientHeight &#125; return 0 &#125; function y() &#123; if (window.pageYOffset) &#123; return window.pageYOffset &#125; return Math.max(document.documentElement.scrollTop, document.body.scrollTop) &#125; function E(e) &#123; var t = m(e); return t &gt;= w &amp;&amp; t &lt;= b + w &#125; function S() &#123; var e = document.createElement("audio"); e.setAttribute("class", l); e.src = i; e.loop = false; e.addEventListener("canplay", function() &#123; setTimeout(function() &#123; x(k) &#125;, 500); setTimeout(function() &#123; N(); p(); for (var e = 0; e &lt; O.length; e++) &#123; T(O[e]) &#125; &#125;, 15500) &#125;, true); e.addEventListener("ended", function() &#123; N(); h() &#125;, true); e.innerHTML = " &lt;p&gt;If you are reading this, it is because your browser does not support the audio element. We recommend that you get a new browser.&lt;/p&gt; &lt;p&gt;"; document.body.appendChild(e); e.play() &#125; function x(e) &#123; e.className += " " + s + " " + o &#125; function T(e) &#123; e.className += " " + s + " " + u[Math.floor(Math.random() * u.length)] &#125; function N() &#123; var e = document.getElementsByClassName(s); var t = new RegExp("\\b" + s + "\\b"); for (var n = 0; n &lt; e.length; ) &#123; e[n].className = e[n].className.replace(t, "") &#125; &#125; var e = 30; var t = 30; var n = 350; var r = 350; var i = "//7xuupy.com1.z0.glb.clouddn.com/tongxingSibel%20-%20Im%20Sorry.mp3"; var s = "mw-harlem_shake_me"; var o = "im_first"; var u = ["im_drunk", "im_baked", "im_trippin", "im_blown"]; var a = "mw-strobe_light"; var f = "//s3.amazonaws.com/moovweb-marketing/playground/harlem-shake-style.css"; var l = "mw_added_css"; var b = g(); var w = y(); var C = document.getElementsByTagName("*"); var k = null; for (var L = 0; L &lt; C.length; L++) &#123; var A = C[L]; if (v(A)) &#123; if (E(A)) &#123; k = A; break &#125; &#125; &#125; if (A === null) &#123; console.warn("Could not find a node of the right size. Please try a different page."); return &#125; c(); S(); var O = []; for (var L = 0; L &lt; C.length; L++) &#123; var A = C[L]; if (v(A)) &#123; O.push(A) &#125; &#125; &#125;)() '&gt;High一下&lt;/a&gt; &lt;/li&gt; 4. 添加最近访客在需要添加最近访客的网页对应的 markdown 文件中添加如下代码：12最近访客&lt;div class=&quot;ds-recent-visitors&quot; data-num-items=&quot;39&quot; data-avatar-size=&quot;40&quot; id=&quot;ds-recent-visitors&quot;&gt;&lt;/div&gt; 5. 鼠标点击小红心的设置 将 love.js 文件添加到 \themes\next\source\js\src 文件目录下。 找到 \themes\next\layout\_layout.swing 文件， 在文件的后面，&lt;/body&gt; 标签之前 添加以下代码：12&lt;!-- 页面点击小红心 --&gt;&lt;script type="text/javascript" src="/js/src/love.js"&gt;&lt;/script&gt; 6. 背景的设置 将 particle.js 文件添加到 \themes\next\source\js\src 文件目录下。 找到 \themes\next\layout\_layout.swing 文件， 在文件的后面，&lt;/body&gt;标签之前 添加以下代码：12&lt;!-- 背景动画 --&gt;&lt;script type="text/javascript" src="/js/src/particle.js"&gt;&lt;/script&gt; 7.修改文章内链接文本样式将链接文本设置为蓝色，鼠标划过时文字颜色加深，并显示下划线。找到文件 themes\next\source\css\_custom\custom.styl ，添加如下 css 样式：12345678.post-body p a &#123; color: #0593d3; border-bottom: none; &amp;:hover &#123; color: #0477ab; text-decoration: underline; &#125;&#125; 8. 多说评论不稳定，加载速度慢怎么办？把多说评论依赖的 embed.js 放置底部，这里需要修改的文件是 duoshuo.swig。将1(document.getElementsByTagName(&apos;head&apos;)[0] 修改成下面的代码1(document.getElementById(&apos;footer&apos;) 9. 给 Github 添加 README默认情况下，Github中每一个项目，我们希望有一份 README.md 的文件来作为项目的说明，但是我们在项目根目录下的 blog\source 目录下创建一份 README.md 文件，写好说明介绍，部署的时候，这个 README.md 会被 hexo 解析掉，而不会被解析到 Github 中去的。正确的解决方法其实很简单： 把 README.md 文件的后缀名改成 “MDOWN” 然后扔到blog/source文件夹下即可，这样 hexo 不会解析，Github 也会将其作为 MD 文件解析。 10. 给 Blog 添加 LICENSE在 主题配置文件 中的 160 行左右：12345# Creative Commons 4.0 International License.# http://creativecommons.org/# Available: by | by-nc | by-nc-nd | by-nc-sa | by-nd | by-sa | zerocreative_commons: by-nc-sa#creative_commons: 将其中第 4 行的注释放开，然后选择你想使用的 LICENSE 即可，可选项参照第 3 行。 最后要说的是： 博客源码 ， 欢迎 star]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo-NexT搭建个人博客（一）]]></title>
    <url>%2F2016%2F09%2F03%2Fhexo-next-one%2F</url>
    <content type="text"><![CDATA[简介Hexo 是一个快速、简洁且高效的静态站点生成框架，它基于 Node.js 。 它有以下特点： 超快速度Node.js 所带来的超快生成速度，让上百个页面在几秒内瞬间完成渲染。 支持MarkdownHexo 支持 GitHub Flavored Markdown 的所有功能，甚至可以整合 Octopress 的大多数插件。 一键部署只需一条指令即可部署到Github Pages，或其他网站 丰富的插件Hexo 拥有强大的插件系统，安装插件可以让 Hexo 支持 Jade, CoffeeScript。 通过 Hexo 你可以轻松地使用 Markdown 编写文章，除了 Markdown 本身的语法之外，还可以使用 Hexo 提供的 标签插件 来快速的插入特定形式的内容。 基于 Hexo 这个优秀的博客框架，很多优秀的开发者奉献出了它们基于 Hexo 开发的主题。NexT 因其 精于心，简于形 的风格，一直被广大用户所喜爱。 安装安装 Hexo 只需几分钟时间，若你在安装过程中遇到问题或无法找到解决方式，请提交问题，我会尽力解决你的问题。 安装前提安装 Hexo 相当简单。然而在安装前，您必须检查电脑中是否已安装下列应用程序: Node.jsGit 如果您的电脑中已经安装上述必备程序，那么恭喜你！接下来只需要使用 npm 即可完成 Hexo 的安装。1$ npm install -g hexo-cli 如果你的电脑中尚未安装所需要的程序，请根据以下安装指示完成安装。 安装 Git Windows：下载安装 git 。 Download Now Mac：使用 Homebrew，MacPorts 或下载 安装程序 安装 Linux（Ubuntu，Debian）：sudo apt-get install git-core Linux（Fedora，Red Hat，CentOS）：sudo yum install git-core 安装 Node.js安装 Node.js 的最佳方式是使用 nvm。（nvm：Node Version Manager）windows 下使用 nvm 请看这里： nvm-windows ，首先需要下载安装 nvm 。 Download Nowwindows下安装完nvm以后，我们可以打开命令行中执行命令12$ nvm$ nvm install latest 执行完以后，重启命令行，执行命令 node -v ，如果出现版本号，那么 Node.js 就安装成功了。 如果没有安装成功，那可能就是墙的原因。建议下载 Node.js 直接安装。 Download Now 安装 Hexo有了 Node.js ，我们可以使用 npm 安装 Hexo。1$ npm install -g hexo-cli 安装 Hexo 完成后，我们首先需要为我们的项目创建一个指定文件夹（例如我在 D 盘目录下创建了一个文件夹 blog 。D:\blog ），在指定文件夹中执行下列命令， Hexo 将会在指定文件夹中新建所需要的文件。1$ hexo init 等待安装，安装完成后，指定文件夹 的目录如下：12345678.├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── 我们继续执行命令12$ hexo g$ hexo s --debug Hexo 将 source 文件夹中除 _posts 文件夹之外，开头命名为 _(下划线)的文件 / 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件夹会被拷贝过去。这个时候，我们在浏览器中访问 http://localhost:4000/ ，就可以看到基于 Hexo 的默认主题的原型： 安装 NexT 主题下载 NexT 主题依旧是在当前目录下，使用 Git checkout 代码：1$ git clone https://github.com/iissnan/hexo-theme-next themes/next 等待下载完成。 在 Hexo 中有两份主要的配置文件，其名称都是 _config.yml 。其中，一份位于站点根目录下，主要包含 Hexo 本身的配置；另一份位于主题目录下，这份配置由主题作者提供，主要用于配置主题相关的选项。 我们约定，将前者称为 站点配置文件，后者称为 主题配置文件 启用 NexT 主题打开 站点配置文件 ，找到 theme 字段，并将其值更改为 next 。到此， NexT 主题安装完成。下一步我们将验证主题是否正确启用。在切换主题之后、验证之前，我们最好使用 hexo clean 来清除 Hexo 的缓存。 验证主题首先启动 Hexo 本地站点，并开启调试模式（即加上 --debug），整个命令是 hexo s --debug。在服务启动的过程，注意观察命令行输出是否有任何异常信息。当命令行输出中提示： 1INFO Hexo is running at http://0.0.0.0:4000/. Press Ctrl+C to stop. 此时即可使用浏览器访问 http://localhost:4000/ ，检查站点是否正确运行。 当你看到站点的外观与下图所示类似时即说明你已成功安装 NexT 主题。这是 NexT 默认的 Scheme —— Muse现在，我们已经成功安装并启用了 NexT 主题。关于更多基本操作和基础知识，请查阅 Hexo 与 NexT 官方文档. 总结本地调试步骤三部曲：123$ hexo clean$ hexo g$ hexo s --debug 这种带 debug 的运行，如果出现错误，可以在命令行中看到错误提示信息。 部署步骤三部曲：123$ hexo clean$ hexo g$ hexo d 当然在部署之前，需要先配置好配置文件中的 deploy。 常用命令1234567$ hexo new "postName" #新建文章$ hexo new page "pageName" # 新建页面$ hexo generate # 生成静态页面至public目录$ hexo server # 开启预览访问端口(默认端口4000，'ctrl+c'关闭server)$ hexo deploy # 项目部署$ hexo help # 查看帮助$ hexo version # 查看Hexo的版本 简写命令1234$ hexo new == hexo n$ hexo generate == hexo g$ hexo server == hexo s$ hexo deploy == hexo d 常见问题1在 hexo 的配置和设置文件中，在冒号后面没留空格会导致出问题：错误的设置：123author:Neveryuemail:react.dong.yu@gmail.comlanguage:zh-CN 正确的设置：123author: Neveryuemail: react.dong.yu@gmail.comlanguage: zh-CN 常见问题2关于 Git 提交中用户名和 Email 的设置12git config --global user.name &quot;Your name&quot;git config --global user.email &quot;Your email&quot; 常见问题3Hexo 中的图标使用的是 Font Awesome ，所以，我们的博客已经自带了 Font Awesome 中的所有图标，基本可以满足我们的所有需求，我们可以去 Font Awesome 中查找我们想要使用的图标。 &lt;i class=&quot;fa fa-github&quot;&gt;&lt;/i&gt; &lt;i class=&quot;fa fa-github fa-lg&quot;&gt;&lt;/i&gt; &lt;i class=&quot;fa fa-github fa-2x&quot;&gt;&lt;/i&gt; 最后要说的是： 博客源码 ， 欢迎 star]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Next</tag>
      </tags>
  </entry>
</search>
